<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction to Netidx</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="quick_start.html"><strong aria-hidden="true">1.</strong> Quick Start</a></li><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="examples/vmstat.html"><strong aria-hidden="true">3.</strong> Example Publishing vmstat</a></li><li class="chapter-item expanded "><a href="administration/overview.html"><strong aria-hidden="true">4.</strong> Administration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="administration/configuration.html"><strong aria-hidden="true">4.1.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="administration/tls.html"><strong aria-hidden="true">4.2.</strong> Managing TLS</a></li><li class="chapter-item expanded "><a href="administration/authorization.html"><strong aria-hidden="true">4.3.</strong> Authorization</a></li><li class="chapter-item expanded "><a href="administration/startup.html"><strong aria-hidden="true">4.4.</strong> Running the Resolver Server</a></li><li class="chapter-item expanded "><a href="administration/listener_check.html"><strong aria-hidden="true">4.5.</strong> Listener Check</a></li><li class="chapter-item expanded "><a href="administration/subscription_flow.html"><strong aria-hidden="true">4.6.</strong> Subscription Flow</a></li><li class="chapter-item expanded "><a href="administration/fault_tolerance.html"><strong aria-hidden="true">4.7.</strong> Fault Tolerance</a></li></ol></li><li class="chapter-item expanded "><a href="tools/overview.html"><strong aria-hidden="true">5.</strong> Command Line Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tools/publisher.html"><strong aria-hidden="true">5.1.</strong> publisher</a></li><li class="chapter-item expanded "><a href="tools/subscriber.html"><strong aria-hidden="true">5.2.</strong> subscriber</a></li><li class="chapter-item expanded "><a href="tools/resolver.html"><strong aria-hidden="true">5.3.</strong> resolver</a></li><li class="chapter-item expanded "><a href="tools/recorder.html"><strong aria-hidden="true">5.4.</strong> recorder</a></li><li class="chapter-item expanded "><a href="tools/container.html"><strong aria-hidden="true">5.5.</strong> container</a></li><li class="chapter-item expanded "><a href="tools/activation.html"><strong aria-hidden="true">5.6.</strong> activation</a></li><li class="chapter-item expanded "><a href="tools/stress.html"><strong aria-hidden="true">5.7.</strong> stress</a></li></ol></li><li class="chapter-item expanded "><a href="examples/integration.html"><strong aria-hidden="true">6.</strong> Example Publishing from Rust</a></li><li class="chapter-item expanded "><a href="browser/overview.html"><strong aria-hidden="true">7.</strong> Browser</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="browser/views.html"><strong aria-hidden="true">7.1.</strong> GUI Builder</a></li><li class="chapter-item expanded "><a href="browser/scripting.html"><strong aria-hidden="true">7.2.</strong> BScript</a></li><li class="chapter-item expanded "><a href="browser/widgets.html"><strong aria-hidden="true">7.3.</strong> Widgets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="browser/frame.html"><strong aria-hidden="true">7.3.1.</strong> Frame</a></li><li class="chapter-item expanded "><a href="browser/box.html"><strong aria-hidden="true">7.3.2.</strong> Box</a></li><li class="chapter-item expanded "><a href="browser/grid.html"><strong aria-hidden="true">7.3.3.</strong> Grid</a></li><li class="chapter-item expanded "><a href="browser/paned.html"><strong aria-hidden="true">7.3.4.</strong> Paned</a></li><li class="chapter-item expanded "><a href="browser/notebook.html"><strong aria-hidden="true">7.3.5.</strong> Notebook</a></li><li class="chapter-item expanded "><a href="browser/table.html"><strong aria-hidden="true">7.3.6.</strong> Table</a></li><li class="chapter-item expanded "><a href="browser/image.html"><strong aria-hidden="true">7.3.7.</strong> Image</a></li><li class="chapter-item expanded "><a href="browser/label.html"><strong aria-hidden="true">7.3.8.</strong> Label</a></li><li class="chapter-item expanded "><a href="browser/button.html"><strong aria-hidden="true">7.3.9.</strong> Button</a></li><li class="chapter-item expanded "><a href="browser/link_button.html"><strong aria-hidden="true">7.3.10.</strong> Link Button</a></li><li class="chapter-item expanded "><a href="browser/switch.html"><strong aria-hidden="true">7.3.11.</strong> Switch</a></li><li class="chapter-item expanded "><a href="browser/toggle_button.html"><strong aria-hidden="true">7.3.12.</strong> Toggle Button</a></li><li class="chapter-item expanded "><a href="browser/combo_box.html"><strong aria-hidden="true">7.3.13.</strong> Combo Box</a></li><li class="chapter-item expanded "><a href="browser/radio_button.html"><strong aria-hidden="true">7.3.14.</strong> Radio Button</a></li><li class="chapter-item expanded "><a href="browser/entry.html"><strong aria-hidden="true">7.3.15.</strong> Entry</a></li><li class="chapter-item expanded "><a href="browser/search_entry.html"><strong aria-hidden="true">7.3.16.</strong> Search Entry</a></li><li class="chapter-item expanded "><a href="browser/scale.html"><strong aria-hidden="true">7.3.17.</strong> Scale</a></li><li class="chapter-item expanded "><a href="browser/progress_bar.html"><strong aria-hidden="true">7.3.18.</strong> Progress Bar</a></li><li class="chapter-item expanded "><a href="browser/line_plot.html"><strong aria-hidden="true">7.3.19.</strong> Line Plot</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="examples/complete_system.html"><strong aria-hidden="true">8.</strong> Example Off Grid Solar Control</a></li><li class="chapter-item expanded "><a href="protocols/overview.html"><strong aria-hidden="true">9.</strong> Protocols Built on Netidx</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="protocols/rpc.html"><strong aria-hidden="true">9.1.</strong> Remote Procedure Call</a></li><li class="chapter-item expanded "><a href="protocols/clustering.html"><strong aria-hidden="true">9.2.</strong> Clustering</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">BScript Reference</li><li class="chapter-item expanded "><a href="bscript/browser.html"><strong aria-hidden="true">10.</strong> Browser Specific Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bscript/browser/confirm.html"><strong aria-hidden="true">10.1.</strong> confirm</a></li><li class="chapter-item expanded "><a href="bscript/browser/current_path.html"><strong aria-hidden="true">10.2.</strong> current_path</a></li><li class="chapter-item expanded "><a href="bscript/browser/event.html"><strong aria-hidden="true">10.3.</strong> event</a></li><li class="chapter-item expanded "><a href="bscript/browser/navigate.html"><strong aria-hidden="true">10.4.</strong> navigate</a></li></ol></li><li class="chapter-item expanded "><a href="bscript/container.html"><strong aria-hidden="true">11.</strong> Container Specific Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bscript/container/event.html"><strong aria-hidden="true">11.1.</strong> event</a></li><li class="chapter-item expanded "><a href="bscript/container/ref.html"><strong aria-hidden="true">11.2.</strong> ref</a></li><li class="chapter-item expanded "><a href="bscript/container/rel.html"><strong aria-hidden="true">11.3.</strong> rel</a></li></ol></li><li class="chapter-item expanded "><a href="bscript/stdfn.html"><strong aria-hidden="true">12.</strong> Standard Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bscript/stdfn/after_idle.html"><strong aria-hidden="true">12.1.</strong> after_idle</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/all.html"><strong aria-hidden="true">12.2.</strong> all</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/and.html"><strong aria-hidden="true">12.3.</strong> and</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/any.html"><strong aria-hidden="true">12.4.</strong> any</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/array.html"><strong aria-hidden="true">12.5.</strong> array</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/basename.html"><strong aria-hidden="true">12.6.</strong> basename</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/call.html"><strong aria-hidden="true">12.7.</strong> call</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/cast.html"><strong aria-hidden="true">12.8.</strong> cast</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/cmp.html"><strong aria-hidden="true">12.9.</strong> cmp</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/contains.html"><strong aria-hidden="true">12.10.</strong> contains</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/count.html"><strong aria-hidden="true">12.11.</strong> count</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/divide.html"><strong aria-hidden="true">12.12.</strong> divide</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/do.html"><strong aria-hidden="true">12.13.</strong> do</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/ends_with.html"><strong aria-hidden="true">12.14.</strong> ends_with</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/eval.html"><strong aria-hidden="true">12.15.</strong> eval</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/filter_err.html"><strong aria-hidden="true">12.16.</strong> filter_err</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/filter.html"><strong aria-hidden="true">12.17.</strong> filter</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/get.html"><strong aria-hidden="true">12.18.</strong> get</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/if.html"><strong aria-hidden="true">12.19.</strong> if</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/index.html"><strong aria-hidden="true">12.20.</strong> index</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/isa.html"><strong aria-hidden="true">12.21.</strong> isa</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/is_error.html"><strong aria-hidden="true">12.22.</strong> is_error</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/load.html"><strong aria-hidden="true">12.23.</strong> load</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/max.html"><strong aria-hidden="true">12.24.</strong> max</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/mean.html"><strong aria-hidden="true">12.25.</strong> mean</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/min.html"><strong aria-hidden="true">12.26.</strong> min</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/not.html"><strong aria-hidden="true">12.27.</strong> not</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/once.html"><strong aria-hidden="true">12.28.</strong> once</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/or.html"><strong aria-hidden="true">12.29.</strong> or</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/product.html"><strong aria-hidden="true">12.30.</strong> product</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/replace.html"><strong aria-hidden="true">12.31.</strong> replace</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/sample.html"><strong aria-hidden="true">12.32.</strong> sample</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/set.html"><strong aria-hidden="true">12.33.</strong> set</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/starts_with.html"><strong aria-hidden="true">12.34.</strong> starts_with</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/store.html"><strong aria-hidden="true">12.35.</strong> store</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/let.html"><strong aria-hidden="true">12.36.</strong> let</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/string_concat.html"><strong aria-hidden="true">12.37.</strong> string_concat</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/string_join.html"><strong aria-hidden="true">12.38.</strong> string_join</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/strip_prefix.html"><strong aria-hidden="true">12.39.</strong> strip_prefix</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/strip_suffix.html"><strong aria-hidden="true">12.40.</strong> strip_suffix</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/sum.html"><strong aria-hidden="true">12.41.</strong> sum</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/timer.html"><strong aria-hidden="true">12.42.</strong> timer</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/trim_end.html"><strong aria-hidden="true">12.43.</strong> trim_end</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/trim.html"><strong aria-hidden="true">12.44.</strong> trim</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/trim_start.html"><strong aria-hidden="true">12.45.</strong> trim_start</a></li><li class="chapter-item expanded "><a href="bscript/stdfn/uniq.html"><strong aria-hidden="true">12.46.</strong> uniq</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Netidx</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="quick-start-for-linux"><a class="header" href="#quick-start-for-linux">Quick Start for Linux</a></h1>
<p>In this quick start we will set up a Netidx resolver server and
related tools on your local machine. This configuration is sufficient
for doing development of netidx services and for trying out various
publishers, subscribers, and tools without much setup.</p>
<h2 id="first-install-rust-and-netidx"><a class="header" href="#first-install-rust-and-netidx">First Install Rust and Netidx</a></h2>
<p>Install <a href="https://www.rust-lang.org/tools/install">rust</a> via rustup if
you haven't already. Ensure cargo is in your and then run,</p>
<p><code>cargo install netidx-tools</code></p>
<p>if you are on Max OS you must use,</p>
<p><code>cargo install --no-default-features netidx-tools</code></p>
<p>This will build and install the <code>netidx</code> command, which contains all
the built in command line tools necessary to run to the resolver
server, as well as the publisher/subscriber command line tools</p>
<p>You will need some build dependencies,</p>
<ul>
<li>libclang, necessary for bindgen, on debian/ubuntu <code>sudo apt install libclang-dev</code></li>
<li>gssapi, necessary for kerberos support, on debian/ubuntu <code>sudo apt install libkrb5-dev</code></li>
</ul>
<h2 id="resolver-server-configuration"><a class="header" href="#resolver-server-configuration">Resolver Server Configuration</a></h2>
<pre><code class="language-json">{
  "parent": null,
  "children": [],
  "member_servers": [
    {
      "pid_file": "",
      "addr": "127.0.0.1:4564",
      "max_connections": 768,
      "hello_timeout": 10,
      "reader_ttl": 60,
      "writer_ttl": 120,
      "auth": {
        "Local": "/tmp/netidx-auth"
      }
    }
  ],
  "perms": {
    "/": {
      "wheel": "swlpd",
      "adm": "swlpd",
      "domain users": "sl"
    }
  }
}
</code></pre>
<p>Install the above config in
<code>~/.config/netidx/resolver.json</code>. This is the config for the
local resolver on your machine. Make sure port 4564 is free, or change
it to a free port of your choosing. If necessary you can change the
local auth socket to one of your choosing.</p>
<p>run <code>netidx resolver-server -c ~/.config/netidx/resolver.json</code>. This command will return
immediatly, and the resolver server will daemonize. Check that it's
running using <code>ps auxwww | grep netidx</code>.</p>
<p>NOTE, the resolver server does not currently support Windows.</p>
<h3 id="systemd"><a class="header" href="#systemd">Systemd</a></h3>
<p>If desired you can start the resolver server automatically with systemd.</p>
<pre><code>[Unit]
Description=Netidx Activation

[Service]
ExecStart=/home/eric/.cargo/bin/netidx resolver-server -c /home/eric/.config/resolver.json -f

[Install]
WantedBy=default.target
</code></pre>
<p>Modify this example systemd unit to match your configuration and then
install it in <code>~/.config/systemd/user/netidx.service</code>. Then you can run</p>
<p><code>systemctl --user enable netidx</code></p>
<p>and</p>
<p><code>systemctl --user start netidx</code></p>
<h2 id="client-configuration"><a class="header" href="#client-configuration">Client Configuration</a></h2>
<pre><code class="language-json">{
    "addrs":
    [
        ["127.0.0.1:4564", {"Local": "/tmp/netidx-auth"}]
    ],
    "base": "/"
}
</code></pre>
<p>Install the above config in <code>~/.config/netidx/client.json</code>. This is
the config all netidx clients (publishers and subscribers) will use to
connect to the resolver cluster.</p>
<ul>
<li>On Mac OS replace <code>~/.config/netidx</code> with <code>~/Library/Application Support/netidx</code>.</li>
<li>On Windows replace <code>~/.config/netidx</code> with <code>~\AppData\Roaming\netidx</code>
(that's <code>{FOLDERID_RoamingAppData}\netidx</code>)</li>
</ul>
<p>To test the configuration run,</p>
<p><code>netidx stress -a local publisher -b 127.0.0.1/0 --delay 1000 1000 10</code></p>
<p>This will publish 10,000 items following the pattern <code>/bench/$r/$c</code>
where <code>$r</code> is a row number and <code>$c</code> is a column
number. e.g. <code>/bench/100/8</code> corresponds to row 100 column 8. The
browser will draw this as a table with 1000 rows and 10 columns,
however for this test we will use the command line subscriber to look
at one cell in the table.</p>
<p><code>netidx subscriber -a local /bench/0/0</code></p>
<p>should print out one line like this every second</p>
<p><code>/bench/0/0|v64|1</code></p>
<p>The final number should increment, and if that works then netidx is
set up on your local machine. If it didn't work, try setting the
environment variable <code>RUST_LOG=debug</code> and running the stress publisher
and the subscriber again.</p>
<h2 id="optional-netidx-browser"><a class="header" href="#optional-netidx-browser">Optional Netidx Browser</a></h2>
<p>The browser is an optional gui browser for the netidx tree, you need
gtk development files installed to build it, on debian/ubuntu add those with</p>
<p><code>sudo apt install libgtk-3-dev</code></p>
<p>and then</p>
<p><code>cargo install netidx-browser</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-netidx"><a class="header" href="#what-is-netidx">What is Netidx</a></h1>
<p>Netidx is middleware that enables publishing a value, like 42, in one
program and consuming it in another program, either on the same
machine or across the network.</p>
<p>Values are given globally unique names in a hierarchical
namespace. For example our published 42 might be named
/the-ultimate-answer (normally we wouldn't put values directly under
the root, but in this case it's appropriate). Any other program on the
network can refer to 42 by that name, and will receive updates in the
(unlikely) event that /the-ultimate-answer changes.</p>
<h2 id="comparison-with-other-systems"><a class="header" href="#comparison-with-other-systems">Comparison With Other Systems</a></h2>
<ul>
<li>
<p>Like LDAP</p>
<ul>
<li>Netidx keeps track of a hierarchical directory of values</li>
<li>Netidx is browsable and queryable to some extent</li>
<li>Netidx supports authentication, authorization, and encryption</li>
<li>Netidx values can be written as well as read.</li>
<li>Larger Netidx systems can be constructed by adding referrals
between smaller systems. Resolver server clusters may have parents
and children.</li>
</ul>
</li>
<li>
<p>Unlike LDAP</p>
<ul>
<li>In Netidx the resolver server (like slapd) only keeps the location
of the publisher that has the data, not the data iself.</li>
<li>There are no 'entries', 'attributes', 'ldif records', etc. Every
name in the system is either structural, or a single value. Entry
like structure is created using hierarchy. As a result there is
also no schema checking.</li>
<li>One can subscribe to a value, and will then be notified immediatly
if it changes.</li>
<li>There are no global filters on data, e.g. you can't query for
(&amp;(cn=bob)(uid=foo)), because netidx isn't a database. Whether and
what query mechanisms exist are up to the publishers. You can,
however, query the structure, e.g. /foo/**/bar would return any
path under foo that ends in bar.</li>
</ul>
</li>
<li>
<p>Like MQTT</p>
<ul>
<li>Netidx values are publish/subscribe</li>
<li>A single Netidx value may have multiple subscribers</li>
<li>All Netidx subscribers receive an update when a value they are
subscribed to changes.</li>
<li>Netidx Message delivery is reliable and ordered.</li>
</ul>
</li>
<li>
<p>Unlike MQTT</p>
<ul>
<li>In Netidx there is no centralized message broker. Messages flow
directly over TCP from the publishers to the subscribers. The
resolver server only stores the address of the publisher/s
publishing a value.</li>
</ul>
</li>
</ul>
<h2 id="the-namespace"><a class="header" href="#the-namespace">The Namespace</a></h2>
<p>Netidx values are published to a hierarchical <a href="https://en.wikipedia.org/wiki/Tuple_space">tuple
space</a>. The structure of
the names look just like a filename, e.g.</p>
<pre><code>/apps/solar/stats/battery_sense_voltage
</code></pre>
<p>Is an example name. Unlike a file name, a netidx name may point to a
value, and also have children. So keeping the file analogy, it can be
both a file and a directory. For example we might have,</p>
<pre><code>/apps/solar/stats/battery_sense_voltage/millivolts
</code></pre>
<p>Where the <code>.../battery_sense_voltage</code> is the number in volts, and it's
'millivolts' child gives the same number in millivolts.</p>
<p>Sometimes a name like <code>battery_sense_voltage</code> is published deep in the
hierarchy and it's parents are just structure. Unlike the file system
the resolver server will create and delete those structural containers
automatically, there is no need to manually manage them.</p>
<p>When a client wants to subscribe to a published value, it queries the
resolver server cluster, and is given the addresses of all the
publishers that publish the value. Multiple publishers can publish the
same value, and the client will try all of them in a random order
until it finds one that works. All the actual data flows from
publishers to subscribers directly without ever going through any kind
of centralized infrastructure.</p>
<h2 id="the-data-format"><a class="header" href="#the-data-format">The Data Format</a></h2>
<p>In Netidx the data that is published is called a value. Values are
mostly primitive types, consisting of numbers, strings, durations,
timestamps, packed byte arrays, and arrays of values. Arrays of values
can be nested.</p>
<p>Byte arrays and strings are zero copy decoded, so they can be a
building block for sending other encoded data efficiently.</p>
<p>Published values have some other properties as well,</p>
<ul>
<li>Every non structural name points to a value</li>
<li>Every new subscription immediately delivers it's most recent value</li>
<li>When a value is updated, every subscriber receives the new value</li>
<li>Updates arrive reliably and in the order the publisher made them
(like a TCP stream)</li>
</ul>
<h2 id="security"><a class="header" href="#security">Security</a></h2>
<p>Netidx currently supports three authentication mechanisms, Kerberos v5,
Local, and Tls. Local applies only on the same machine (and isn't supported
on Windows), while many organizations already have Kerberos v5
deployed in the form of Microsoft Active Directory, Samba ADS, Redhat
Directory Server, or one of the many other compatible solutions. Tls
requires each participant in netidx (resolver server, subscriber, publisher)
to have a certificate issued by a certificate authority that the others
it wants to interact with trust.</p>
<p>Security is optional in netidx, it's possible to deploy a netidx
system with no security at all, or it's possible to deploy a mixed
system where only some publishers require security, with some
restrictions.</p>
<ul>
<li>If a subscriber is configured with security, then it won't talk to
publishers that aren't.</li>
<li>If a publisher is configured with security, then it won't talk to a
subscriber that isn't.</li>
</ul>
<p>When security is enabled, regardless of which of the three mechanisms
you get the following guarantees,</p>
<ul>
<li>
<p><strong>Mutual Authentication</strong>, the publisher knows the subscriber is who
they claim to be, and the subscriber knows the publisher is who they
claim to be. This applies for the resolver &lt;-&gt; subscriber, and
resolver &lt;-&gt; publisher as well.</p>
</li>
<li>
<p><strong>Confidentiality</strong> and Tamper detection, all messages are encrypted
if they will leave the local machine, and data cannot be altered
undetected by a man in the middle.</p>
</li>
<li>
<p><strong>Authorization</strong>, The user subscribing to a given data value is
authorized to do so. The resolver servers maintain a permissions
database specifying who is allowed to do what where in the
tree. Thus the system administrator can centrally control who is
allowed to publish and subscribe where.</p>
</li>
</ul>
<h2 id="cross-platform"><a class="header" href="#cross-platform">Cross Platform</a></h2>
<p>While netidx is primarily developed on Linux, it has been tested on
Windows, and Mac OS.</p>
<h2 id="scale"><a class="header" href="#scale">Scale</a></h2>
<p>Netidx has been designed to support single namespaces that are pretty
large. This is done by allowing delegation of subtrees to different
resolver clusters, which can be done to an existing system without
disturbing running publishers or subscribers. Resolver clusters
themselves can also have a number of replicas, with read load split
between them, further augmenting scaling.</p>
<p>At the publisher level, multiple publishers may publish the same
name. When a client subscribes it will randomly pick one of them. This
property can be used to balance load on an application, so long as the
publishers syncronize with each other.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing-vmstat"><a class="header" href="#publishing-vmstat">Publishing vmstat</a></h1>
<p>In this example we build a shell script to publish the output of the
venerable vmstat tool to netidx.</p>
<pre><code class="language-bash">#! /bin/bash

BASE="/sys/vmstat/$HOSTNAME"

vmstat -n 1 | \
    while read running \
               blocked \
               swapped \
               free \
               buf \
               cache \
               swap_in \
               swap_out \
               blocks_in \
               blocks_out \
               interrupts \
               context_switches \
               user \
               system \
               idle \
               waitio \
               stolen
    do
        echo "${BASE}/running|z32|${running}"
        echo "${BASE}/blocked|z32|${blocked}"
        echo "${BASE}/swapped|z32|${swapped}"
        echo "${BASE}/free|u64|${free}"
        echo "${BASE}/buf|u64|${buf}"
        echo "${BASE}/cache|u64|${cache}"
        echo "${BASE}/swap_in|z32|${swap_in}"
        echo "${BASE}/swap_out|z32|${swap_out}"
        echo "${BASE}/blocks_in|z32|${blocks_in}"
        echo "${BASE}/blocks_out|z32|${blocks_out}"
        echo "${BASE}/interrupts|z32|${interrupts}"
        echo "${BASE}/context_switches|z32|${context_switches}"
        echo "${BASE}/user|z32|${user}"
        echo "${BASE}/system|z32|${system}"
        echo "${BASE}/idle|z32|${idle}"
        echo "${BASE}/waitio|z32|${waitio}"
        echo "${BASE}/stolen|z32|${stolen}"
    done | \
    netidx publisher --spn publish/${HOSTNAME}@RYU-OH.ORG --bind 192.168.0.0/24
</code></pre>
<p>Lets dissect this pipeline of three commands into it's parts. First
vmstat itself, if you aren't familiar with it, is part of the <code>procps</code>
package on debian, which is a set of fundamental unix tools like
<code>pkill</code>, <code>free</code>, and <code>w</code> which would have been familiar to sysadmins
in the 80s.</p>
<pre><code>vmstat -n 1
</code></pre>
<p>prints output like this</p>
<pre><code>eric@ken-ohki:~$ vmstat -n 1
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 2  0 279988 4607136 1194752 19779448    0    0     5    48   14    8 15  6 79  0  0
 0  0 279988 4605104 1194752 19780728    0    0     0     0 1800 3869  4  1 95  0  0
 0  0 279988 4605372 1194752 19780632    0    0     0     0 1797 4175  3  1 96  0  0
 0  0 279988 4604104 1194752 19781672    0    0     0     0 1982 4570  4  1 95  0  0
 0  0 279988 4604112 1194752 19780648    0    0     0     0 1941 4690  3  2 95  0  0
</code></pre>
<p><code>-n</code> means only print the header once, and <code>1</code> means print a line
every second until killed. Next we pass these lines to a shell while
loop that reads the line using the builtin <code>read</code> command into a shell
variable for each field. The field names were changed to be more
descriptive. In the body of the while loop we echo a <code>path|typ|value</code>
triple for each field. e.g. if we don't run the final pipe to <code>netidx publisher</code> the output of the while loop looks something like this.</p>
<pre><code>/sys/vmstat/ken-ohki.ryu-oh.org/running|z32|1
/sys/vmstat/ken-ohki.ryu-oh.org/blocked|z32|0
/sys/vmstat/ken-ohki.ryu-oh.org/swapped|z32|279988
/sys/vmstat/ken-ohki.ryu-oh.org/free|u64|4644952
/sys/vmstat/ken-ohki.ryu-oh.org/buf|u64|1194896
/sys/vmstat/ken-ohki.ryu-oh.org/cache|u64|19775864
/sys/vmstat/ken-ohki.ryu-oh.org/swap_in|z32|0
/sys/vmstat/ken-ohki.ryu-oh.org/swap_out|z32|0
/sys/vmstat/ken-ohki.ryu-oh.org/blocks_in|z32|5
/sys/vmstat/ken-ohki.ryu-oh.org/blocks_out|z32|48
/sys/vmstat/ken-ohki.ryu-oh.org/interrupts|z32|14
/sys/vmstat/ken-ohki.ryu-oh.org/context_switches|z32|9
/sys/vmstat/ken-ohki.ryu-oh.org/user|z32|15
/sys/vmstat/ken-ohki.ryu-oh.org/system|z32|6
/sys/vmstat/ken-ohki.ryu-oh.org/idle|z32|79
/sys/vmstat/ken-ohki.ryu-oh.org/waitio|z32|0
/sys/vmstat/ken-ohki.ryu-oh.org/stolen|z32|0
</code></pre>
<p>No surprise that this is the exact format <code>netidx publisher</code> requires
to publish a value, so the final command in the pipeline is just
<code>netidx publisher</code> consuming the output of the while loop.</p>
<p>Running this on two of my systems results in a table viewable in the
browser with two rows,</p>
<p><img src="examples/vmstat-browser-table.png" alt="vmstat" /></p>
<p>Because of the way the browser works, our regular tree structure is
automatically turned into a table with a row for each host, and a
column for each vmstat field. So we've made something that's
potentially useful to look at with very little effort. There are many
other things we can now do with this data, for example we could use
<code>netidx record</code> to record the history of vmstat on these machines, we
could subscribe, compute an aggregate, and republish it, or we could
sort by various columns in the browser. How about we have some fun and
pretend that all the machines running the script are part of an
integrated cluster, as if it was that easy, and so we want a total
vmstat for the cluster.</p>
<pre><code class="language-bash">#! /bin/bash

BASE='/sys/vmstat'
declare -A TOTALS
declare -A HOSTS

netidx resolver list -w "${BASE}/**" | \
    grep -v --line-buffered "${BASE}/total/" | \
    sed -u -e 's/^/ADD|/' | \
    netidx subscriber | \
    while IFS='|' read -a input
    do
        IFS='/' path=(${input[0]})
        host=${path[-2]}
        field=${path[-1]}
        if ! test -z "$host" -o -z "$field"; then
            HOSTS[$host]="$host"
            TOTALS["$host/$field"]=${input[2]}
            T=0
            for h in ${HOSTS[@]}
            do
                ((T+=TOTALS["$h/$field"]))
            done
            echo "${BASE}/total/$field|${input[1]}|$T"
        fi
    done | netidx publisher --spn publish/${HOSTNAME}@RYU-OH.ORG --bind 192.168.0.0/24
</code></pre>
<p>Lets dissect this script,</p>
<pre><code>netidx resolve list -w "${BASE}/**"
</code></pre>
<p>This lists everything under <code>/sys/vmstat</code> recursively, and instead of
exiting after doing that, it keeps polling every second, and if a new
thing shows up that matches the glob it lists the new thing. The
output is just a list of paths, e.g.</p>
<pre><code>...
/sys/vmstat/total/blocked
/sys/vmstat/total/buf
/sys/vmstat/total/system
/sys/vmstat/blackbird.ryu-oh.org/swap_out
/sys/vmstat/ken-ohki.ryu-oh.org/buf
/sys/vmstat/ken-ohki.ryu-oh.org/idle
...
</code></pre>
<p>The next two commands in the pipeline serve to filter out the total
row we are going to publish (don't want to recursively total things
right), and transform the remaining lines into commands to <code>netidx subscriber</code> that will cause it to add a subscription. e.g.</p>
<pre><code>...
ADD|/sys/vmstat/ken-ohki.ryu-oh.org/waitio
ADD|/sys/vmstat/blackbird.ryu-oh.org/blocked
ADD|/sys/vmstat/blackbird.ryu-oh.org/context_switches
ADD|/sys/vmstat/blackbird.ryu-oh.org/free
...
</code></pre>
<p>The above is what gets fed into the <code>netidx subscriber</code> command. So in
a nutshell we've said subscribe to all the things anywhere under
<code>/sys/vmstat</code> that are present now, or appear in the future, and
aren't part of the total row. Subscriber prints a line for each
subscription update in the form of a <code>PATH|TYP|VAL</code> triple, e.g.</p>
<pre><code>..
/sys/vmstat/ken-ohki.ryu-oh.org/swap_out|z32|0
/sys/vmstat/ken-ohki.ryu-oh.org/blocks_in|z32|0
/sys/vmstat/ken-ohki.ryu-oh.org/blocks_out|z32|16
/sys/vmstat/ken-ohki.ryu-oh.org/interrupts|z32|1169
/sys/vmstat/ken-ohki.ryu-oh.org/context_switches|z32|3710
/sys/vmstat/ken-ohki.ryu-oh.org/user|z32|3
/sys/vmstat/ken-ohki.ryu-oh.org/system|z32|1
/sys/vmstat/ken-ohki.ryu-oh.org/idle|z32|96
...
</code></pre>
<p>That gets passed into our big shell while loop, which uses the <code>read</code>
builtin to read each line into an array called input. So in the body
of each iteration of the the while loop the variable <code>input</code> will be
an array with contents e.g.</p>
<pre><code>[/sys/vmstat/ken-ohki.ryu-oh.org/swap_out, v32, 25]
</code></pre>
<p>Indexed starting at 0 as is the convention in bash. We split the path
into an array called <code>path</code>, the last two elements of which are
important to us. The last element is the field (e.g. <code>swap_out</code>), and
the second to last is the host. Each line is an update to one field of
one host, and when a field of a host is updated we want to compute the
sum of that field for all the hosts, and then print the new total for
that field. To do this we need to remember each field for each host,
since only one field of one host gets updated at a time. For this we
use an associative array with a key of <code>$host/$field</code>, thats
<code>TOTALS</code>. We also need to remember all the host names, so that when we
are ready to compute our total, we can look up the field for every
host, that's <code>HOSTS</code>. Finally we pass the output of this while loop to
the publisher, and now we have a published total row.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="administration"><a class="header" href="#administration">Administration</a></h1>
<h2 id="first-things-first"><a class="header" href="#first-things-first">First Things First</a></h2>
<p>If you plan to use Kerberos make sure you have it set up properly,
including your KDC, DNS, DHCP, etc. If you need help with kerberos I
suggest the <a href="https://www.oreilly.com/library/view/kerberos-the-definitive/0596004036/">O'REILLY
book</a>. If
you want something free the <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/">RedHat
documentation</a>
isn't too bad, though it is somewhat specific to their product.</p>
<p>Problems with Kerberos/GSSAPI can often be diagnosed by setting
<code>KRB5_TRACE=/dev/stderr</code>, and/or <code>RUST_LOG=debug</code>. GSSAPI errors can
sometimes be less than helpful, but usually the KRB5_TRACE is more
informative.</p>
<h2 id="resources-and-gotchas"><a class="header" href="#resources-and-gotchas">Resources and Gotchas</a></h2>
<ul>
<li>
<p>Expect to use about 500 MiB of ram in the resolver server for every
1 million published values.</p>
</li>
<li>
<p>Both read and write operations will make use of all available
logical processors on the machine. So, in the case you are hitting
performance problems, try allocating more cores before taking more
drastic segmentation steps.</p>
</li>
<li>
<p>Even when the resolvers are very busy they should remain fair. Large
batches of reads or writes are broken into smaller reasonably sized
batches for each logical processor. These batches are then
interleaved pseudo randomly to ensure that neither reads nor writes
are starved.</p>
</li>
<li>
<p>Be mindful of the maximum number of available file descriptors per
process on the resolver server machine when setting
max_connections. You can easily raise this number on modern linux
systems using ulimit.</p>
</li>
<li>
<p>While the resolver server drops idle read client connections fairly
quickly (default 60 seconds), if you have many thousands or tens of
thousands of read clients that want to do a lot of reading
simultaneously then you may need to raise the maximum number of file
descriptors available, and/or deploy additional processes to avoid
file descriptor exhaustion.</p>
</li>
<li>
<p>Some implementations of Krb5/GSSAPI keep a file descriptor open for
every active client/server session, which in our case means every
read client, but also every publisher, connected or not. This has
been fixed in recent versions of MIT Kerberos (but may still
manifest if you are running with KRB5_TRACE). Keep this in mind if
you're seeing file descriptor exhaustion.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="resolver-server-configuration-1"><a class="header" href="#resolver-server-configuration-1">Resolver Server Configuration</a></h2>
<p>Each resolver server cluster shares a configuration file. At startup
time each member server is told it's zero based index in the list of
member servers. Since the default is 0 the argument can be omitted if
there is only one server in the cluster.</p>
<p>Here is an example config file for a resolver cluster that lives in
the middle of a three level hierarchy. Above it is the root server, it
is responsible for the /app subtree, and it delegates /app/huge0 and
/app/huge1 to child servers.</p>
<pre><code class="language-json">{
  "parent": {
    "path": "/app",
    "ttl": 3600,
    "addrs": [
      [
        "192.168.0.1:4654",
        {
          "Krb5": "root/server@YOUR-DOMAIN"
        }
      ]
    ]
  },
  "children": [
    {
      "path": "/app/huge0",
      "ttl": 3600,
      "addrs": [
        [
          "192.168.0.2:4654",
          {
            "Krb5": "huge0/server@YOUR-DOMAIN"
          }
        ]
      ]
    },
    {
      "path": "/app/huge1",
      "ttl": 3600,
      "addrs": [
        [
          "192.168.0.3:4654",
          {
            "Krb5": "huge1/server@YOUR-DOMAIN"
          }
        ]
      ]
    }
  ],
  "member_servers": [
    {
      "pid_file": "/var/run/netidx",
      "addr": "192.168.0.4:4564",
      "max_connections": 768,
      "hello_timeout": 10,
      "reader_ttl": 60,
      "writer_ttl": 120,
      "auth": {
        "Krb5": "app/server@YOUR-DOMAIN"
      }
    }
  ],
  "perms": {
    "/app": {
      "wheel": "swlpd",
      "adm": "swlpd",
      "domain users": "sl"
    }
  }
}
</code></pre>
<h3 id="parent"><a class="header" href="#parent">parent</a></h3>
<p>This section is either null if the cluster has no parent, or a record
specfying</p>
<ul>
<li>
<p>path: The path where this cluster attaches to the parent. For
example a query for something in /tmp would result in a referral to
the parent in the above example, because /tmp is not a child of
/app, so this cluster isn't authoratative for /tmp. It's entirely
posible that the parent isn't authoratative for /tmp either, in
which case the client would get another referral upon querying the
parent. This chain of referrals can continue until a maximum number
is reached (to prevent infinite cycles).</p>
</li>
<li>
<p>ttl: How long, in seconds, clients should cache this parent. If for
example you reconfigured it to point to another IP, clients might
still try to go to the old ip for as long as the ttl.</p>
</li>
<li>
<p>addrs: The addresses of the servers in the parent cluster. This is a
list of pairs of ip:port and auth mechanism. The authentication
mechanism of the parent may not be Local, it must be either
Anonymous or Krb5. In the case of Krb5 you must include the server's
spn.</p>
</li>
</ul>
<h3 id="children"><a class="header" href="#children">children</a></h3>
<p>This section contains a list of child clusters. The format of each
child is exactly the same as the parent section. The path field is the
location the child attaches in the tree, any query at or below that
path will be referred to the child.</p>
<h3 id="member_servers"><a class="header" href="#member_servers">member_servers</a></h3>
<p>This section is a list of all the servers in this cluster. The fields
on each server are,</p>
<ul>
<li>
<p>id_map_command: Optional. The path to the command the server should run
in order to map a user name to a user and a set of groups that user is
a member of. Default is <code>/usr/bin/id</code>. If a custom command is specified
then it's output MUST be in the same format as the <code>/usr/bin/id</code> command.
This command will be passed the name of the user as a single argument.
Depending on the auth mechanism this "name" could be e.g. <code>eric@RYU-OH.ORG</code> for
kerberos, just <code>eric</code> for local auth, or <code>eric.users.architect.com</code> for
tls auth (it will pass the common name of the users' certificate)</p>
</li>
<li>
<p>pid_file: the path to the pid file you want the server to write. The
server id folowed by .pid will be appended to whatever is in this
field. So server 0 in the above example will write it's pid to
/var/run/netidx0.pid</p>
</li>
<li>
<p>addr: The socket address and port that this member server will report
to clients. This should be it's public ip, the ip clients use to connect
to it from the outside.</p>
</li>
<li>
<p>bind_addr: The socket address that the server will actually bind to on
the local machine. This defaults to 0.0.0.0. In the case where you are
behind a NAT, or some other contraption, you should set this to the private
ip address corresponding to the interface you actually want to receive
traffic on.</p>
</li>
<li>
<p>max_connections: The maximum number of simultaneous client
connections that this server will allow. Client connections in
excess of this number will be accepted and immediatly closed (so
they can hopefully try another server).</p>
</li>
<li>
<p>hello_timeout: The maximum time, in seconds, that the server will
wait for a client to complete the initial handshake
process. Connections that take longer than this to handshake will be
closed.</p>
</li>
<li>
<p>reader_ttl: The maximum time, in seconds, that the server will retain
an idle read connection. Idle read connections older than this will
be closed.</p>
</li>
<li>
<p>writer_ttl: The maximum time, in seconds, that the server will
retain an idle write connection. Idle connections older than this
will be closed, and all associated published data will be
cleared. Publishers autoatically set their heartbeat interval to
half this value. This is the maximum amount of time data from a dead
publisher will remain in the resolver.</p>
</li>
<li>
<p>auth: The authentication mechanism used by this server. One of
Anonymous, Local, Krb5, or Tls. Local must include the path to the local
auth socket file that will be used to verify the identity of
clients. Krb5 must include the server's spn. Tls must include the
domain name of the server, the path to the trusted certificates,
the server's certificate (it's CN must match the domain name),
and the path to the server's private key. For example,</p>
<pre><code class="language-json">"Tls": {
    "name": "resolver.architect.com",
    "trusted": "trusted.pem",
    "certificate": "cert.pem",
    "private_key": "private.key"
}
</code></pre>
<p>The certificate <code>CN</code> must be <code>resolver.architect.com</code>. The
may not be encrypted.</p>
</li>
</ul>
<h3 id="perms"><a class="header" href="#perms">perms</a></h3>
<p>The server perissions map. This will be covered in detail in the
authorization chapter. If a member server's auth mechanism is
anonymous, then this is ignored.</p>
<h2 id="client-configuration-1"><a class="header" href="#client-configuration-1">Client Configuration</a></h2>
<p>Netidx clients such as publishers and subscribers try to load their
configuration files from the following places in order.</p>
<ul>
<li>$NETIDX_CFG</li>
<li>config_dir:
<ul>
<li>on Linux: ~/.config/netidx/client.json</li>
<li>on Windows: ~\AppData\Roaming\netidx\client.json</li>
<li>on MacOS: ~/Library/Application Support/netidx/client.json</li>
</ul>
</li>
<li>global_dir
<ul>
<li>on Linux: /etc/netidx/client.json</li>
<li>on Windows: C:\netidx\client.json</li>
<li>on MacOS: /etc/netix/client.json</li>
</ul>
</li>
</ul>
<p>Since the dirs crate is used to discover these paths, they are locally
configurable by OS specific means.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-json">{
    "addrs":
    [
        ["192.168.0.1:4654", {"Krb5": "root/server@YOUR-DOMAIN"}]
    ],
    "base": "/"
}
</code></pre>
<h4 id="addrs"><a class="header" href="#addrs">addrs</a></h4>
<p>A list of pairs or ip:port and auth mechanism for each server in the
cluster. Local should include the path to the local authentication
socket file. Krb5 should include the server's spn.</p>
<h4 id="base"><a class="header" href="#base">base</a></h4>
<p>The base path of this server cluster in the tree. This should
correspond to the server cluster's parent, or "/" if it's parent is
null.</p>
<h4 id="default_auth"><a class="header" href="#default_auth">default_auth</a></h4>
<p>Optional. Specify the default authentication mechanism. May be one of
<code>Anonymous</code>, <code>Local</code>, <code>Krb5</code>, or <code>Tls</code></p>
<h4 id="tls"><a class="header" href="#tls">tls</a></h4>
<p>This is required only if using tls. Because netidx is a
distributed system, when in tls mode a subscriber may need to interact
with different organizations that don't necessarially trust each other enough
to share a certificate authority. That is why subscribers may be configured
with multiple identities. When connecting to another netidx entity a
subscriber will pick the identity that most closely matches the domain
of that entity. For example, in the below config, when connecting to
<code>resolver.footraders.com</code> the client will use the <code>footraders.com</code> identity.
When connecting to <code>core.architect.com</code> it will choose the <code>architect.com</code>
identity. When connecting to <code>a-feed.marketdata.architect.com</code> it would
choose the <code>marketdata.architect.com</code> identity.</p>
<p>When publishing, the default identity is used unless another identity is
specified to the publisher.</p>
<pre><code class="language-json">"tls": {
    "default_identity": "footraders.com",
    "identities": {
        "footraders.com": {
            "trusted": "/home/joe/.config/netidx/footradersca.pem",
            "certificate": "/home/joe/.config/netidx/footraders.crt",
            "private_key": "/home/joe/.config/netidx/footraders.key"
        },
        "architect.com": {
            "trusted": "/home/joe/.config/netidx/architectca.pem",
            "certificate": "/home/joe/.config/netidx/architect.crt",
            "private_key": "/home/joe/.config/netidx/architect.key"
        },
        "marketdata.architect.com": {
            "trusted": "/home/joe/.config/netidx/architectca.pem",
            "certificate": "/home/joe/.config/netidx/architectmd.crt",
            "private_key": "/home/joe/.config/netidx/architectmd.key"
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-tls"><a class="header" href="#managing-tls">Managing TLS</a></h1>
<p>Tls authentication requires a bit more care than even Kerberos. Here we'll go over
a quick configuration using the openssl command line tool. I'll be using,</p>
<pre><code>$ openssl version
OpenSSL 3.0.2 15 Mar 2022 (Library: OpenSSL 3.0.2 15 Mar 2022)
</code></pre>
<h2 id="setting-up-a-local-certificate-authority"><a class="header" href="#setting-up-a-local-certificate-authority">Setting Up a Local Certificate Authority</a></h2>
<p>Unless you already have a corporate certificate authority, or you actually want to buy
certificates for your netidx resolvers, publishers, and users from a commercial CA then
you need to set up a certificate authority. This sounds like a big deal, but it's actually
not. A CA is really just a certificate and accompanying private key that serves as the root
of trust. That means that it is self signed, and people in your organization choose to trust
it. It will then sign certificates for your users, publishers, and resolver servers, and they
will be configured to trust certificates that it has signed.</p>
<pre><code>openssl genrsa -aes256 -out ca.key 4096
</code></pre>
<p>This will generate the private key we will use for the local ca. This is the most important
thing to keep secret. Use a strong password on it, and ideally keep it somewhere safe.</p>
<pre><code>openssl req -new -key ./ca.key -x509 -sha512 -out ca.crt -days 7300 \
  -subj "/CN=mycompany.com/C=US/ST=Some State/L=Some City/O=Some organization" \
  -addext "basicConstraints=critical, CA:TRUE" \
  -addext "subjectKeyIdentifier=hash" \
  -addext "authorityKeyIdentifier=keyid:always, issuer:always" \
  -addext "keyUsage=critical, cRLSign, digitalSignature, keyCertSign" \
  -addext "subjectAltName=DNS:mycompany.com"
</code></pre>
<p>This will generate a certificate for the certificate authority and sign it with the private key.
The <code>-addext</code> flags add x509v3 attributes. Once this is complete we can view the certificate with</p>
<pre><code>openssl x509 -text -in ca.crt
</code></pre>
<h2 id="generating-user-resolver-and-publisher-certificates"><a class="header" href="#generating-user-resolver-and-publisher-certificates">Generating User, Resolver, and Publisher Certificates</a></h2>
<p>Now we can create certificates for various parts of the netidx system. Lets make one for the resolver
server.</p>
<pre><code># generate the resolver server key. It must not be encrypted.
openssl genrsa -out resolver.key 4096

# generate a certificate signing request that will be signed our CA
openssl req -new -key ./resolver.key -sha512 -out resolver.req \
  -subj "/CN=resolver.mycompany.com/C=US/ST=Some State/L=Some City/O=Some organization"

# sign the certificate request with the CA key and add restrictions to it using x509v3 extentions
openssl x509 -req -in ./resolver.req -CA ca.crt -CAkey ca.key \
  -CAcreateserial -out resolver.crt -days 730 -extfile &lt;(cat &lt;&lt;EOF
basicConstraints=critical, CA:FALSE
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid:always, issuer:always
keyUsage=nonRepudiation,digitalSignature,keyEncipherment
subjectAltName=DNS:resolver.mycompany.com
EOF
)

 # check it
openssl verify -trusted ca.crt resolver.crt
</code></pre>
<p>This has one extra step, the generation of the request to be signed. If we were using a commercial
certificate authority we would send this request to them and they would return the signed certificate
to us. In this case it's just an extra file we can delete once we've signed the request.</p>
<p>The resolver server private key must not be encrypted, this is because it probably doesn't have any
way to ask for a password on startup, since it's likely running on a headless server somewhere.
So it's extra important to keep this certificate safe.</p>
<p>Generating user and publisher certificates is exactly the same as the above, except that they are
permitted to have password protected private keys. However if you do this, make sure there is an
<code>askpass</code> command configured, and that your system level keychain service is running and unlocked.
Once the password has been entered once, it will be added to the keychain and should not need to
be entered again.</p>
<p>It's possible to use the same certificate for multiple services, however it's probably not a great
idea unless it's for multiple components of the same system (e.g. lots of publishers in a cluster),
or if a user is testing a new publisher it can probably just use their certificate.</p>
<h2 id="distributing-certificates"><a class="header" href="#distributing-certificates">Distributing Certificates</a></h2>
<p>With the configuration above you only need to distribute the CA certificate. Every netidx component
that will participate needs to have a copy of it, and it needs to be configured as trusted in the client
config, and the resolver server config.</p>
<p>Other components only need to have their own certificate, as well as their private key.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authorization"><a class="header" href="#authorization">Authorization</a></h1>
<p>When using the Kerberos, Local, or Tls auth mechanisms we also need to
specify permissions in the cluster config file, e.g.</p>
<pre><code class="language-json">...
"perms": {
    "/": {
        "eric@RYU-OH.ORG": "swlpd"
    },
    "/solar": {
	    "svc_solar@RYU-OH.ORG": "pd"
    }
}
</code></pre>
<p>In order to do the corresponding action in netidx a user must have
that permission bit set. Permission bits are computed starting from
the root proceeding down the tree to the node being acted on. The bits
are accumulated on the way down. Each bit is represented by a 1
character symbolic tag, e.g.</p>
<ul>
<li>!: Deny, changes the meaning of the following bits to deny the
corresponding permission instead of grant it. May only be the first
character of the permission string.</li>
<li>s: Subscribe</li>
<li>w: Write</li>
<li>l: List</li>
<li>p: Publish</li>
<li>d: Publish default</li>
</ul>
<p>For example if I was subscribing to
<code>/solar/stats/battery_sense_voltage</code> we would walk down the path from
left to right and hit this permission first,</p>
<pre><code class="language-json">"/": {
    "eric@RYU-OH.ORG": "swlpd"
},
</code></pre>
<p>This applies to a Kerberos principal "eric@RYU-OH.ORG", the resolver
server will check the user principal name of the user making the
request, and it will check all the groups that user is a member of,
and if any of those are "eric@RYU-OH.ORG" then it will <code>or</code> the
current permission set with "swlpd". In this case this gives me
permission to do anything I want in the whole tree (unless it is later
denied). Next we would hit,</p>
<pre><code class="language-json">"/solar": {
    "svc_solar@RYU-OH.ORG": "pd"
}
</code></pre>
<p>Which doesn't apply to me, and so would be ignored, and since there
are no more permissions entries my effective permissions at
<code>/solar/stats/battery_sense_voltage</code> are "swlpd", and so I would be
allowed to subscribe.</p>
<p>Suppose however I changed the above entry,</p>
<pre><code class="language-json">"/solar": {
    "svc_solar@RYU-OH.ORG": "pd",
    "eric@RYU-OH.ORG": "!swl",
}
</code></pre>
<p>Now, in our walk, when we arrived at <code>/solar</code>, we would find an entry
that matches me, and we would remove the permission bits s, w, and l,
leaving our effective permissions at
<code>/solar/stats/battery_sense_voltage</code> as "pd". Since that doesn't give
me the right to subscribe my request would be denied. We could also do
this by group.</p>
<pre><code class="language-json">"/solar": {
    "svc_solar@RYU-OH.ORG": "pd",
    "RYU-OH\domain admins": "!swl",
}
</code></pre>
<p>As you would expect, this deny permission will still apply to me
because I am a member of the domain admins group. If I am a member of
two groups, and both groups have different bits denied, then all of
them would be removed. e.g.</p>
<pre><code class="language-json">"/solar": {
    "svc_solar@RYU-OH.ORG": "pd",
    "RYU-OH\domain admins": "!swl",
    "RYU-OH\enterprise admins": "!pd",
}
</code></pre>
<p>Now my effective permissions under <code>/solar</code> are empty, I can do
nothing. If I am a member of more than one group, and one denies
permissions that the other grants the deny always takes precidence.</p>
<p>Each server cluster is completely independent for permissions. If for
example this cluster had a child cluster, the administrators of that
cluster would be responsible for deciding it's permissions map.</p>
<h3 id="anonymous"><a class="header" href="#anonymous">Anonymous</a></h3>
<p>It's possible to give anonymous users permissions even on a Kerberos
or Local auth mechanism system, and this could allow them to use
whatever functions you deem non sensitive, subject to some
limitations. There is no encryption. There is no tamper
protection. There is no publisher -&gt; subscriber
authentication. Anonymous users can't subscribe to non anonymous
publishers. Non anonymous users can't subscribe to anonymous
publishers. You name anonymous "" in the permissions file, e.g.</p>
<pre><code class="language-json">"/tmp": {
    "": "swlpd"
}
</code></pre>
<p>Now <code>/tmp</code> is an anonymous free for all. If you have Kerberos
deployed, it's probably not that useful to build such a hybrid system,
because any anonymous publishers would not be usable by kerberos
enabled users. However it might be useful if you have embedded systems
that can't use kerberos, and you don't want to build a separate
resolver server infrastructure for them.</p>
<h3 id="groups"><a class="header" href="#groups">Groups</a></h3>
<p>You'll might have noticed I'm using AD style group names above, that's
because my example setup uses Samba in ADS mode so I can test windows
and unix clients on the same domain. The most important thing about
the fact that I'm using Samba ADS and thus have the group names I have
is that it doesn't matter. Groups are just strings to netidx, for a
given user, whatever the <code>id</code> command would spit out for that user is
what it's going to use for the set of groups the user is in (so that
better match what's in your permissions file). You need to set up the
resolver server machines such that they can properly resolve the set
of groups every user who might use netidx is in.</p>
<p>Luckily you only need to get this right on the machines that run
resolver servers, because that's the only place group resolution
happens in netidx. You're other client and server machines can be as
screwed up and inconsistent as you want, as long as the resolver
server machine agrees that I'm a member of "RYU-OH\domain admins" then
whatever permissions assigned to that group in the permission file
will apply to me.</p>
<p>All the non resolver server machines need to be able to do is get
Kerberos tickets. You don't even need to set them up to use Kerberos
for authentication (but I highly recommend it, unless you really hate
your users), you can just force people to type <code>kinit foo@BAR.COM</code>
every 8 hours if you like.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-the-resolver-server"><a class="header" href="#running-the-resolver-server">Running the Resolver Server</a></h1>
<p>As of this writing the resolver server only runs on Unix, and has only
been extensively tested on Linux. There's no reason it couldn't run on
Windows, it's just a matter of some work around group name resolution
and service integration. Starting a resolver server is done from the
<code>netidx</code> command line tool (<code>cargo install netidx-tools</code>). e.g.</p>
<pre><code class="language-bash">$ KRB5_KTNAME=FILE:/path/to/keytab \
netidx resolver-server -c resolver.json
</code></pre>
<p>By default the server will daemonize, include <code>-f</code> to prevent that. If
your cluster has multiple replica servers then you must pass <code>--id &lt;index&gt;</code> to specify which one you are starting, however since the
default is 0 you can omit the id argument in the case where you only
have 1 replica.</p>
<p>You can test that it's working by running,</p>
<pre><code class="language-bash">$ netidx resolver list /
</code></pre>
<p>Which should print nothing (since you have nothing published), but
should not error, and should run quickly. You can use the command line
publisher and subscriber to further test. In my case I can do,</p>
<pre><code class="language-bash">[eric@blackbird ~]$ netidx publisher \
    --bind 192.168.0.0/24 \
    --spn host/blackbird.ryu-oh.org@RYU-OH.ORG &lt;&lt;EOF
/test|string|hello world
EOF
</code></pre>
<p>and then I can subscribe using</p>
<pre><code class="language-bash">[eric@blackbird ~]$ netidx subscriber /test
/test|string|hello world
</code></pre>
<p>you'll need to make sure you have permission, that you have a keytab
you can read with that spn in it, and that the service principal
exists etc. You may need to, for example, run the publisher and/or
resolver server with</p>
<p><code>KRB5_KTNAME=FILE:/somewhere/keytabs/live/krb5.keytab</code></p>
<p><code>KRB5_TRACE=/dev/stderr</code> can be useful in debugging kerberos issues.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="listener-check"><a class="header" href="#listener-check">Listener Check</a></h1>
<p>The listener check is an extra security measure that is intended to
prevent an authenticated user from denying service to another
publisher by overwriting it's session. When a client connects
to the resolver server for write, and kerberos, tls, or local auth
is enabled, then after authentication the resolver server encrypts
a challenge using the newly created session. It then connects to the write address
proposed by this new publisher and presents the challenge, which the
publisher must answer correctly, otherwise the old session will be
kept, and the new client will be disconnected. So in order to publish
at a given address you must,</p>
<ul>
<li>Be a valid user</li>
<li>Actually be listening on the write address you propose to use for
publishing. And the write address must be routable from the resolver
server's position on the network.</li>
<li>Have permission to publish where you want to publish.</li>
</ul>
<h2 id="why-is-the-listener-check-important"><a class="header" href="#why-is-the-listener-check-important">Why is the listener check important?</a></h2>
<p>Since connecting to the resolver as a publisher can be done by any
user who can authenticate to the resolver, and since the address and port a
publisher is going to insert into the resolver server as their address
is just part of the hello message, without some kind of check anyone
on your network could figure out the address of an important
publisher, then connect to the resolver server and say they <em>are</em> that
publisher address, even if they don't have permission to publish. There
are several implications.</p>
<ul>
<li>publishers on different network segments that might share ip
addresses can't use the same resolver server.</li>
<li>the resolver must be able to route back to every publisher, and also
it must be able to actually connect. For example your firewall must
allow connections both ways.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="subscription-flow"><a class="header" href="#subscription-flow">Subscription Flow</a></h2>
<p>Sometimes debugging problems requires a more detailed understanding of
exactly what steps are involved in a subscription.</p>
<h3 id="components"><a class="header" href="#components">Components</a></h3>
<p><img src="administration/subscription-flow-components.png" alt="The Components" /></p>
<p>In the full kerberos enabled version of netidx the following
components are involved.</p>
<ul>
<li>The Kerberos 5 KDC (Key Distribution Center). e.g. The AD Domain Controller.</li>
<li>Resolver Cluster, holds the path of everything published and the
address of the publisher publishing it.</li>
<li>Subscriber</li>
<li>Publisher, holds the actual data, and has previously told the
resolver server about the path of all the data it has.</li>
</ul>
<h3 id="step-1"><a class="header" href="#step-1">Step 1</a></h3>
<p><img src="administration/subscription-flow-step1.png" alt="First Step" /></p>
<ol>
<li>The Subscriber asks the KDC for a service ticket to talk to the
Resolver Cluster. Note this only happens once for each user for
some amount of time (usually hours), after which the service ticket
is cached. The subscriber proves it's identity to the KDC using
it's TGT.</li>
<li>The KDC, having checked the validity of the subscriber's identity,
generates a service ticket for the resolver server cluster. NOTE,
Kerberos does not make authorization decisions, it merely allows
entities to prove to each other that they are who they claim to be.</li>
</ol>
<h3 id="step-2"><a class="header" href="#step-2">Step 2</a></h3>
<p><img src="administration/subscription-flow-step2.png" alt="Second Step" /></p>
<ol start="3">
<li>The Subscriber uses the service ticket to establish an encrypted
GSSAPI session with the Resolver Cluster.</li>
<li>Using the session it just established sends a resolve request for
the paths it wants to subscribe to. All traffic is encrypted using
the session.</li>
<li>The Resolver Cluster verifies the presented GSSAPI token and
establishes a secure session, looks up the requested paths, and
returns a number of things to the subscriber for each path.
<ul>
<li>The addresses of all the publishers who are publishing that path</li>
<li>The service principal names of those publishers</li>
<li>The permissions the subscriber has to the path</li>
<li>The authorization token, which is a SHA512 hash of the concatenation of
<ul>
<li>A secret shared by the Resolver Cluster and the Publisher</li>
<li>The path</li>
<li>The permissions</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="step-3"><a class="header" href="#step-3">Step 3</a></h3>
<p><img src="administration/subscription-flow-step3.png" alt="Third Step" /></p>
<ol start="6">
<li>The subscriber picks a random publisher from the set of publishers
publishing the path it wants, and requests a service ticket for
that publisher's SPN from the KDC.</li>
<li>The KDC validates the subscriber's TGT and returns a service ticket
for the requested SPN, which will be cached going forward (usually
for several hours).</li>
</ol>
<h3 id="step-4"><a class="header" href="#step-4">Step 4</a></h3>
<p><img src="administration/subscription-flow-step4.png" alt="Fourth Step" /></p>
<ol start="8">
<li>
<p>The subscriber uses the service ticket it just obtained to
establish an encrypted GSSAPI session with the publisher, and using
this session it sends a subscribe request, which consists of,</p>
<ul>
<li>The path it wants to subscribe to</li>
<li>The permissions the resolver cluster gave to it</li>
<li>The authorization token</li>
</ul>
</li>
<li>
<p>The publisher validates the subscriber's GSSAPI token and
establishes an encrypted session, and then reads the subscribe
request. It looks up the request path, and assuming it is
publishing that path, it constructs a SHA512 hash value of,</p>
<ul>
<li>The secret it shared with the resolver cluster when it initially
published the path.</li>
<li>The path the subscriber is requesting</li>
<li>The permissions the subscriber claims to have</li>
</ul>
<p>It then checks that it's constructed auth token matches the one the
subscriber presented. Since the subscriber does not know the secret
the publisher shared with the resolver server it is computationally
infeasible for the subscriber to generate a valid hash value for an
arbitrary path or permissions, therefore checking this hash is an
effective proof that the resolver cluster really gave the
subscriber the permissions it is claiming to have.</p>
<p>Assuming all the authentication and authorization checks out, and
the publisher actually publishes the requested value, it sends the
current value back to the publisher along with the ID of the
subscription.</p>
<p>Whenever the value changes the publisher sends the new value along
with the ID of the subscription to the publisher (encrypted using
the GSSAPI session, and over the same TCP session that was
established earlier).</p>
</li>
</ol>
<h3 id="other-authentication-methods"><a class="header" href="#other-authentication-methods">Other Authentication Methods</a></h3>
<p>In the case of Tls and Local authentication, the subscription flow is similar,
it just doesn't involve the KDC. Under local authentication, the resolver server
is listening on a unix domain socket at an agreed upon path. The client connects
to the socket, and the server is able to determine the local user on the other end.
It then sends the client a token that it can use to make requests. From step 2 on local
auth is more or less the same as kerberos.</p>
<p>Tls is very similar as well, except instead of a kdc, it's doing a TLS handshake. If the
certificates check out, then from step 2 on, it's pretty much identical to kerberos.</p>
<p>In the case of anonymous authentication it's just a simple matter of look up the address
from the resolver, and then subscribe to the publisher. All the data goes in the clear.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fault-tolerance"><a class="header" href="#fault-tolerance">Fault Tolerance</a></h1>
<p>As a system netidx depends on fault tolerant strategies in the
subscriber, publisher, and resolver server in order to minimize
downtime caused by a failure. Before I talk about the specific
strategies used by each component I want to give a short taxonomy of
faults as I think of them so we can be clear about what I'm actually
talking about.</p>
<ul>
<li>Hang: Where a component of the system is not 'dead', e.g. the
process is still running, but is no longer responding, or is so slow
it may as well not be responding. IMHO this is the worst kind of
failure. It can happen at many different layers, e.g.
<ul>
<li>You can simulate a hang by sending SIGSTOP to a unix process. It
isn't dead, but it also won't do anything.</li>
<li>A machine with a broken network card, such that most packets are
rejected due to checksum errors, it's still on the network, but
it's effective bandwidth is a tiny fraction of what it should be.</li>
<li>A software bug causing a deadlock</li>
<li>A malfunctioning IO device</li>
</ul>
</li>
<li>Crash: A process or the machine it's running on crashes cleanly and
completely.</li>
<li>Bug: A semantic bug in the system that causes an effective end to
service.</li>
<li>Misconfiguration: An error in the configuration of the system that
causes it not to work. e.g.
<ul>
<li>Resolver server addresses that are routeable by some clients and not others</li>
<li>Wrong Kerberos SPNs</li>
<li>Misconfigured Kerberos</li>
<li>Bad tls certificates</li>
</ul>
</li>
</ul>
<h3 id="subscriber--publisher"><a class="header" href="#subscriber--publisher">Subscriber &amp; Publisher</a></h3>
<ul>
<li>
<p>Hang: Most hang situations are solved by heartbeats. Publisher sends
a heartbeat to every subscriber that is connected to it every 5
seconds. Subscriber disconnects if it doesn't reveive at least 1
message every 100 seconds.</p>
<p>Once a hang is detected it is dealt with by disconnecting, and it
essentially becomes a crash.</p>
<p>The hang case that heartbeats don't solve is when data is flowing,
but not fast enough. This could have multiple causes e.g. the
subscriber is too slow, the publisher is too slow, or the link
between them is too slow. Whatever the cause, the publisher can
handle this condition by providing a timeout to it's <code>flush</code>
function. This will cause any subscriber that can't consume the
flushed batch within the specified timeout to be disconnected.</p>
</li>
<li>
<p>Crash: Subscriber allows the library user to decide how to deal with
a publisher crash. If the lower level <code>subscribe</code> function is used
then on being disconnected unexpecetedly by the publisher all
subscriptions are notified and marked as dead. The library user is
free to retry. The library user could also use <code>durable_subscribe</code>
which will dilligently keep trying to resubscribe, with linear
backoff, until it is successful. Regardless of whether you retry
manually or use <code>durable_subscribe</code> each retry will go through the
entire process again, so it will eventually try all the publishers
publishing a value, and it will pick up any new publishers that
appear in the resolver server.</p>
</li>
</ul>
<h3 id="resolver"><a class="header" href="#resolver">Resolver</a></h3>
<ul>
<li>Hang: Resolver clients deal with a resolver server hang with a
dynamically computed timeout based on the number of requests in the
batch. The rule is, minimum timeout 15 seconds or 50 microseconds
per simple operation in the batch for reads (longer for complex read
ops like list matching) or 100 microseconds per simple operation in
the batch for writes, whichever is longer. That timeout is a timeout
to get an answer, not to finish the batch. Since the resolver server
breaks large batches up into smaller ones, and answers each micro
batch when it's done, the timeout should not usually be hit if the
resolver is just very busy, since it will be sending back something
periodically for each micro batch. The intent is for the timeout to
trigger if the resolver is really hanging.</li>
<li>Crash: Resolver clients deal with crashes differently depending on
whether they are read or write connections.
<ul>
<li>Read Connections (Subscriber): Abandon the current connection, wait a random
time between 1 and 12 seconds, and then go through the whole
connection process again. That roughly entails taking the list of
all servers, permuting it, and then connecting to each server in
the list until one of them answers, says a proper hello, and
successfully authenticates (if authentication is on). For each batch a
resolver client will do this abandon and reconnect dance 3 times,
and then it will give up and return an error for that
batch. Subsuquent batches will start over from the beginning. In a
nutshell read clients will,
<ul>
<li>try every server 3 times in a random order</li>
<li>only give up on a batch if every server is down or unable to answer</li>
<li>remain in a good state to try new batches even if previous batches have failed</li>
</ul>
</li>
<li>Write Connections (Publishers): Since write connections are
responsible for replicating their data out to each resolver server
they don't include some of the retry logic used in the read
client. They do try to replicate each batch 3 times seperated by a
1-12 second pause to each server in the cluster. If after 3 tries
they still can't write to one of the servers then it is marked as
degraded. The write client will try to replicate to a degraded
server again at each heartbeat interval. In a nutshell write
clients,
<ul>
<li>try 3 times to write to each server</li>
<li>try failed servers again each 1/2 <code>writer_ttl</code></li>
<li>never fail a batch, just log an error and keep trying</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>One important consequence of the write client behavior is that in the
event all the resolver servers crash, when they come back up
publishers will republish everything after a maximum of 1/2
<code>writer_ttl</code> has elapsed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-tools"><a class="header" href="#command-line-tools">Command Line Tools</a></h1>
<p>You don't need to program to use netidx, it comes with a set of useful
command line tools!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-publisher"><a class="header" href="#command-line-publisher">Command Line Publisher</a></h1>
<p>The command line publisher allows you to publish values to netidx from
stdin. The format of a published value is pipe separated, and newline
delimited. e.g.</p>
<p><code>/foo/bar|u32|42</code></p>
<p>The three fields are,</p>
<ul>
<li>The path</li>
<li>The type</li>
<li>The value</li>
</ul>
<p>or the special form</p>
<ul>
<li>The path</li>
<li><code>null</code></li>
</ul>
<p>or the special form</p>
<ul>
<li>DROP</li>
<li>the path</li>
</ul>
<p>e.g. <code>DROP|/foo/bar</code> stops publishing <code>/foo/bar</code></p>
<p>or the special form</p>
<ul>
<li>WRITE</li>
<li>the path</li>
</ul>
<p>e.g. <code>WRITE|/foo/bar</code></p>
<p>enables writing to <code>/foo/bar</code>, and publishes it as <code>null</code> if it was
not already published. Written values will be sent to stdout in the
same format as is written by subscriber.</p>
<p>If you want to publish to a path that has a <code>|</code> character in it then
you must escape the <code>|</code> with <code>\</code>, e.g. <code>\|</code>. If you want to publish a
path that has a <code>\</code> in it, then you must also escape it,
e.g. <code>\\</code>. e.g.</p>
<p><code>/this/path/has\|pipes\|and\\in-it|string|pipe and backslash everywhere</code></p>
<h2 id="arguments"><a class="header" href="#arguments">Arguments</a></h2>
<p>There are several command line options to the <code>netidx publisher</code> command,</p>
<ul>
<li><code>-b, --bind</code>: optional, specify the network address to bind to. This can
be specified in three forms.
<ul>
<li>an expression consisting of an ip/netmask that must match a unique
network interface on the machine running the publisher. This is
prefered, e.g.
<ul>
<li>local, selects 127.0.0.1/24</li>
<li>10.0.0.0/8 selects the interface bound to a 10.x.x.x address</li>
<li>192.168.0.0/16 selects the interface bound to a 192.168.x.x address</li>
<li>The publisher will choose a free port automatically starting at 5000</li>
</ul>
</li>
<li>if you must specify an exact address and port e.g.
<ul>
<li>127.0.0.1:5000</li>
<li>127.0.0.1:0, in which case the OS will choose the port at
random, depending on the OS/libc this may pick an ephemeral
port, so be careful.</li>
</ul>
</li>
<li>a public ip followed by the first or second forms for the internal bind ip.
Use this if you are running publishers behind a NAT (e.g. aws elastic ips)
<ul>
<li>54.32.223.1@172.31.0.0/16 will bind to any interface matching 172.31.0.0,
but will advertise it's address to the resolver as 54.32.223.1.</li>
<li>54.32.224.1@0.0.0.0/32 will bind to every interface on the local machine
but will advertise it's address to the resolver as 54.32.223.1.</li>
<li>54.32.224.1:5001@172.31.23.234:5001 will bind to 172.31.23.234 on port 5001
but will advertise it's address to the resolver as 54.32.224.1:5001. This
would correspond to a typical single port forward NAT situation.</li>
</ul>
</li>
</ul>
</li>
<li><code>-a, --auth</code>: optional, specifies the authentication mechanism,
anonymous, local, or krb5.</li>
<li><code>--spn</code>: optional, required if -a krb5, the service principal name
the publisher should run as. This principal must have permission to
publish where you plan to publish, must exist in your krb5
infrastructure, and you must have access to a keytab with it's
credentials. If that keytab is in a non standard location then you
must set the environment variable
<code>KRB5_KTNAME=FILE:/the/path/to/the/keytab</code></li>
<li><code>--upn</code>: optional, if you want to authenticate the publisher to the
resolver server as a prinicpal other than the logged in user then
you can specify that principal here. You must have a TGT for the
specified principal.</li>
<li><code>--identity</code>: optional, the tls identity to use for publishing.</li>
<li><code>--timeout &lt;seconds&gt;</code>: optional, if specified requires subscribers
to consume published values within the specified number of seconds
or be disconnected. By default the publisher will wait forever for a
subscriber to consume an update, and as a result could consume an
unbounded amount of memory.</li>
</ul>
<h2 id="behavior"><a class="header" href="#behavior">Behavior</a></h2>
<p>When started the publisher runs until killed, it reads lines from
stdin as long as stdin remains open, and attempts to parse them as
<code>PATH|TYPE|VALUE</code> triples. If parsing fails, it prints an error to
stderr and continues reading. If parsing succeeds it checks if it has
already published <code>PATH</code>, if not, it publishes it with the specified
type and value, if it has, then it updates the existing published
value. It is not an error to change the type of an existing published
value. If stdin is closed publisher does not stop, however it is no
longer possible to update existing published values, or publish new
values without restarting it.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>The command line publisher cannot be a default publisher.</p>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h2>
<p>In addition to all the krb5 environment variables, the command line
publisher uses envlogger, and so will respond to <code>RUST_LOG</code>,
e.g. <code>RUST_LOG=debug</code> will cause the publisher to print debug and
higher priority messages to stderr.</p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>The following types are supported,</p>
<ul>
<li><code>u32</code>: unsigned 32 bit integer, 4 bytes on the wire</li>
<li><code>v32</code>: unsigned 32 bit integer <a href="https://en.wikipedia.org/wiki/LEB128">LEB128 encoded</a>, 1-5 bytes on the wire depending on how big the number is. e.g. 0-128 is just 1 byte</li>
<li><code>i32</code>: signed 32 bit integer, 4 bytes on the wire</li>
<li><code>z32</code>: signed 32 bit integer <a href="https://en.wikipedia.org/wiki/LEB128">LEB128 encoded</a> 1-5 bytes on the wire</li>
<li><code>u64</code>: unsigned 64 bit integer, 8 bytes on the wire</li>
<li><code>v64</code>: unsigned 64 bit integer <a href="https://en.wikipedia.org/wiki/LEB128">LEB128 encoded</a>, 1-10 bytes on the wire</li>
<li><code>i64</code>: signed 64 bit integer, 8 bytes on the wire</li>
<li><code>z64</code>: signed 64 bit integer <a href="https://en.wikipedia.org/wiki/LEB128">LEB128 encoded</a>, 1-10 bytes on the wire</li>
<li><code>f32</code>: 32 bit single precision floating point number, 4 bytes on the wire</li>
<li><code>f64</code>: 64 bit double precision floating point number, 8 bytes on the wire</li>
<li><code>datetime</code>: a date + time encoded as an i64 timestamp representing
the number of seconds since jan 1 1970 UTC and a u32 number of sub
second nanoseconds fixing the exact point in time. 12 bytes on the
wire</li>
<li><code>duration</code>: a duration encoded as a u64 number of seconds plus a u32
number of sub second nanoseconds fixing the exact duration. 12 bytes on the wire</li>
<li><code>bool</code>: true, or false. 1 byte on the wire</li>
<li><code>string</code>: a unicode string, limited to 1 GB in length. Consuming 1-10 + number of bytes in the string on the wire (the length is LEB128 encoded)</li>
<li><code>bytes</code>: a byte array, limited to 1 GB in length, Consuming 1-10 + number of bytes in the array on the wire</li>
<li><code>array</code>: an array of netidx values, consuming 1+zlen(array)+sum(len(elts))</li>
<li><code>result</code>: OK, or Error + string, consuming 1-1+string length bytes</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-subscriber"><a class="header" href="#command-line-subscriber">Command Line Subscriber</a></h1>
<p>The command line subscriber allows you to subscribe to values in
netidx. You can either specify a list of paths you want to subscribe
to on the command line, or via commands sent to stdin. Once subscribed
a line in the form <code>PATH|TYPE|VALUE</code> will be printed for every update
to a subscribed value, including the initial value. e.g. on my local
network I can get the battery voltage of my solar array by typing,</p>
<pre><code>netidx subscriber /solar/stats/battery_sense_voltage
/solar/stats/battery_sense_voltage|f32|26.796875
</code></pre>
<h2 id="directives-via-stdin"><a class="header" href="#directives-via-stdin">Directives via stdin</a></h2>
<p>The command line subscriber reads commands from stdin which can direct it to,</p>
<ul>
<li>subscribe to a new path
<ul>
<li><code>ADD|/path/to/thing/you/want/to/add</code></li>
</ul>
</li>
<li>end a subscription
<ul>
<li><code>DROP|/path/to/thing/you/want/to/drop</code></li>
</ul>
</li>
<li>write a value to a subscribed path
<ul>
<li><code>WRITE|/path/to/thing/you/want/to/write|TYPE|VALUE</code></li>
<li>if the path you are writing to has a <code>|</code> in it, then you must
escape it, e.g. <code>\|</code>. If it has a literal <code>\</code> in it, then you also
must escape it e.g. <code>\\</code>.</li>
</ul>
</li>
<li>call a netidx rpc
<ul>
<li><code>CALL|/path/to/the/rpc|arg=typ:val,...,arg=typ:val</code></li>
<li>commas in the val may be escaped with <code>\</code></li>
<li>args may be specified multiple times</li>
</ul>
</li>
</ul>
<p>If the subscriber doesn't recognize a command it will print an error
to stderr and continue reading commands. If stdin is closed subscriber
will not quit, but it will no longer be possible to issue commands.</p>
<h2 id="arguments-1"><a class="header" href="#arguments-1">Arguments</a></h2>
<ul>
<li>
<p><code>-o, --oneshot</code>: Causes subscriber to subscribe to each requested
path, get one value, and then unsubscribe. In oneshot mode, if all
requested subscriptions have been processed, and either stdin is
closed, or <code>-n, --no-stdin</code> was also specified, then subscriber will
exit. e.g.</p>
<p><code>netidx subscriber -no /solar/stats/battery_sense_voltage</code></p>
<p>Will subscribe to <code>/solar/stats/battery_sense_voltage</code>, print out
the current value, and then exit.</p>
</li>
<li>
<p><code>-n, --no-stdin</code>: Do not read commands from stdin, only subscribe to
paths passed on the command line. In this mode it is not possible to
unsubscribe, write, or add new subscriptions after the program starts.</p>
</li>
<li>
<p><code>-r, --raw</code>: Do not print the path and type, just the value. <code>-nor</code>
is useful for printing the value of one or more paths to stdout and
then exiting.</p>
</li>
<li>
<p><code>-t, --subscribe-timeout</code>: Instead of retrying failed subscriptions
forever, only retry them for the specified number of seconds, after
that remove them, and possibly exit if <code>-o, --oneshot</code> was also
specified.</p>
</li>
</ul>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<p>The format subscriber writes to stdout is compatible with the format
the publisher reads (unless -r is specified). This is by design, to
make applications that subscribe, manipulate, and republish data easy
to write.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resolver-command-line-tool"><a class="header" href="#resolver-command-line-tool">Resolver Command Line Tool</a></h1>
<p>The resolver command line tool allows you to query and update the
resolver server from the command line. There are several kinds of
querys/manipulations it can perform,</p>
<ul>
<li><code>list</code>: list entries matching a specified pattern</li>
<li><code>table</code>: query the table descriptor for a path</li>
<li><code>resolve</code>: see what a path resolves to</li>
<li><code>add</code>: add a new entry</li>
<li><code>remove</code>: remove an entry</li>
</ul>
<h2 id="list"><a class="header" href="#list">List</a></h2>
<p><code>netidx resolver list /solar/stats/*</code></p>
<p>This sub command allows listing items in the resolver server that
match a specific pattern. It supports the full unix glob pattern set,
including <code>**</code> meaning any number of intermediate parents, and
<code>{thing1, thing2, thing3, ..}</code> for specifying specific sets. e.g. on
my machine I can get all the names under the <code>/solar</code> namespace that
begin with <code>battery</code> with the following query,</p>
<pre><code>$ netidx resolver list /solar/**/battery*
/solar/settings/battery_charge_current_limit
/solar/stats/battery_v_max_daily
/solar/stats/battery_current_net
/solar/stats/battery_voltage_slow
/solar/stats/battery_voltage_settings_multiplier
/solar/stats/battery_sense_voltage
/solar/stats/battery_v_min_daily
/solar/stats/battery_temperature
/solar/stats/battery_terminal_voltage
</code></pre>
<h3 id="args"><a class="header" href="#args">Args</a></h3>
<p>List supports several arguments,</p>
<ul>
<li><code>-n, --no-structure</code>: don't list matching items that are structural
only. Only list items that are actually published.</li>
<li><code>-w, --watch</code>: don't quit, instead wait for new items matching the
pattern and print them out as they appear.</li>
</ul>
<h2 id="table"><a class="header" href="#table">Table</a></h2>
<p>This prints out the table desciptor for a path, which can tell you how
a given path will look in the browser by default. An example 10 row 5
column table generated by the stress publisher looks like this,</p>
<pre><code>$ netidx resolver table /bench
columns:
2: 10
0: 10
1: 10
4: 10
3: 10
rows:
/bench/3
/bench/5
/bench/6
/bench/9
/bench/8
/bench/7
/bench/2
/bench/4
/bench/1
/bench/0
</code></pre>
<p>in the columns section, the number after the column name is the number
of rows in the table that have that column. Since this table is fully
populated every column is associated with 10 rows.</p>
<h2 id="resolve"><a class="header" href="#resolve">Resolve</a></h2>
<p>Given a path(s) this prints out all the information the resolver
server has about that path. This is what the subscriber uses to
connect to a publisher, and as such this tool is useful for debugging
subscription failures. Using the same stress publisher we saw above we
can query one cell in the table.</p>
<pre><code>[eric@blackbird ~]$ netidx resolver resolve /local/bench/0/0
publisher: Publisher { resolver: 127.0.0.1:4564, id: PublisherId(3), addr: 127.0.0.1:5011, hash_method: Sha3_512, target_auth: Local }
PublisherId(3)
</code></pre>
<p>First all the publisher records are printed. This is the full
information about all the publishers that publish the requested
paths. Then, a list of publisher ids is printed, this is the publisher
id that corresponds to each path in the order the path was
specified. If we asked for two paths under the /local/bench namespace
then we will see how this works.</p>
<pre><code>[eric@blackbird ~]$ netidx resolver resolve /local/bench/0/0 /local/bench/0/1
publisher: Publisher { resolver: 127.0.0.1:4564, id: PublisherId(3), addr: 127.0.0.1:5011, hash_method: Sha3_512, target_auth: Local }
PublisherId(3)
PublisherId(3)
</code></pre>
<p>Here we can clearly see that the same publisher (publisher id 3) is
the one to contact about both requested paths. This output closely
mirrors how the actual information is sent on the wire (except on the
wire it's binary, and the ids are varints). If multiple publishers
published any of the requested paths, their ids would appear on the
same line separated by commas.</p>
<p>In the case that nothing is publishing the requested path then the
tool will print nothing and exit.</p>
<h2 id="add"><a class="header" href="#add">Add</a></h2>
<p>This is a low level debugging tool, and it's really not recommended
unless you know exactly what you're doing. Using it could screw up
subscriptions to whatever path you add for some time. That said, it's
pretty simple,</p>
<pre><code>netidx resolver add /path/to/thing 192.168.0.5:5003
</code></pre>
<p>This entry will time out after a while because no publisher is there
to send heartbeats for it.</p>
<p>Note this will not work if your system is kerberos enabled, because
the resolver server checks that the publisher is actually listening on
the address it claims to be listening on, and that obviously can't
work in this case.</p>
<h2 id="remove"><a class="header" href="#remove">Remove</a></h2>
<p>This is actually worse than add in terms of danger, because you can
remove published things without the publisher knowing you did it, and
as a result you can make subscriptions fail until the publisher is
restarted. It also doesn't work if you are using kerberos, so that's something.</p>
<pre><code>netidx resolver remove /path/to/thing 192.168.0.5:5003`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recorder"><a class="header" href="#recorder">Recorder</a></h1>
<p>The recorder allows you to subscribe to a set of paths defined by one
or more globs and write down their values in a file with a compact
binary format. Moreover, at the same time it can make the contents of
an archive available for playback by multiple simultaneous client
sessions, each with a potentially different start time, playback
speed, end time, and position.</p>
<p>It's possible to set up a recorder to both record data and play it
back at the same time, or only record, or only play back. It is not
possible to set up one recorder to record, and another to play back
the same file, however recording and playback are careful not to
interfere with each other, so the only limitation should be the
underlying IO device and the number of processor cores available.</p>
<h2 id="args-1"><a class="header" href="#args-1">Args</a></h2>
<ul>
<li><code>--example</code>: optional, print an example configuration file</li>
<li><code>--config</code>: required, path to the recorder config file</li>
</ul>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>e.g.</p>
<pre><code>{
  "archive_directory": "/foo/bar",
  "archive_cmds": {
    "list": [
      "cmd_to_list_dates_in_archive",
      []
    ],
    "get": [
      "cmd_to_fetch_file_from_archive",
      []
    ],
    "put": [
      "cmd_to_put_file_into_archive",
      []
    ]
  },
  "netidx_config": null,
  "desired_auth": null,
  "record": {
    "spec": [
      "/tmp/**"
    ],
    "poll_interval": {
      "secs": 5,
      "nanos": 0
    },
    "image_frequency": 67108864,
    "flush_frequency": 65534,
    "flush_interval": {
      "secs": 30,
      "nanos": 0
    },
    "rotate_interval": {
      "secs": 86400,
      "nanos": 0
    }
  },
  "publish": {
    "base": "/archive",
    "bind": null,
    "max_sessions": 512,
    "max_sessions_per_client": 64,
    "shards": 0
  }
}
</code></pre>
<ul>
<li><code>archive_directory</code>: The directory where archive files will be
written. The archive currently being written is <code>current</code> and
previous rotated files are named the rfc3339 timestamp when they
ended.</li>
<li><code>archive_commands</code>: These are shell hooks that are run when various
events happen
<ul>
<li><code>list</code>: Shell hook to list available historical archive
files. This will be combined with the set of timestamped files in
<code>archive_directory</code> to form the full set of available archive
files.</li>
<li><code>get</code>: Shell hook that is run before an archive file needs to be
accessed. It will be accessed just after this command
returns. This can, for example, move the file into place after
fetching it from long term storage. It is passed the name of the
file the archiver would like, which will be in the union of the
local files and the set returned by list.</li>
<li><code>pub</code>: Shell hook that is run just after the current file is
rotated. Could, for example, back the newly rotated file up, or
move it to long term storage.</li>
</ul>
</li>
<li><code>netidx_config</code>: Optional path to the netidx config. Omit to use the default.</li>
<li><code>desired_auth</code>: Optional desired authentication mechanism. Omit to use the default.</li>
<li><code>record</code>: Section of the config used to record, omit to only play back.
<ul>
<li><code>spec</code>: a list of globs describing what to record. If multiple
globs are specified and they overlap, the overlapped items will
only be archived once.</li>
<li><code>poll_interval</code>: How often, in seconds, to poll the resolver
server for changes to the specified glob set. 0 never poll,
if omitted, the default is 5 seconds.</li>
<li><code>image_frequency</code>: How often, in bytes, to write a full image of
every current value, even if it did not update. Writing images
increases the file size, but makes seeking to an arbitrary
position in the archive much faster. 0 to disable images, in which
case a seek back will read all the data before the requested
position, default 64MiB.</li>
<li><code>flush_frequency</code>: How much data to write before flushing to disk,
in pages, where a page is a filesystem page. default 65534. This
is the maximum amount of data you will probably lose in a power
outage, system crash, or program crash. The recorder uses two
phase commits to the archive file to ensure that partially written
data does not corrupt the file.</li>
<li><code>flush_interval</code>: How long in seconds to wait before flushing data
to disk even if <code>flush_frequency</code> pages was not yet written. 0 to
disable, default if omitted 30 seconds.</li>
<li><code>rotate_interval</code>: How long in seconds to wait before rotating the
current archive file. Default if omitted, never rotate.</li>
</ul>
</li>
<li><code>publish</code>: Section of the config file to enable publishing
<ul>
<li><code>base</code>: The base path to publish at</li>
<li><code>bind</code>: The bind config to use. Omit to use the default.</li>
<li><code>max_sessions</code>: The maximum total number of replay sessions
concurrently in progress.</li>
<li><code>max_sessions_per_client</code>: The maximum number of replay sessions
in progress for any single client.</li>
<li><code>shards</code>: The number of recorder shards to expect. If you want to
record/playback a huge namespace, or one that updates a lot, it
may not be possible to use just one computer. The recorder
supports sharding across an arbitrary number of processes for both
recording and playback. n is the number of shards that are
expected in a given cluster. playback will not be avaliable until
all the shards have appeared and synced with each other, however
recording will begin immediatly. default if omitted 0 (meaning
just one recorder).</li>
</ul>
</li>
</ul>
<h2 id="using-playback-sessions"><a class="header" href="#using-playback-sessions">Using Playback Sessions</a></h2>
<p>When initially started for playback or mixed operation the recorder
publishes only some cluster information, and a netidx rpc called
<code>session</code> under the <code>publish-base</code>. Calling the session rpc will
create a new session, and return the session id. Then it will publish
the actual playback session under <code>publish-base/session-id</code>. A
playback session consists of two sub directories, <code>control</code> contains
readable/writable values that control the session, and <code>data</code> contains
the actual data.</p>
<h3 id="creating-a-new-session"><a class="header" href="#creating-a-new-session">Creating a New Session</a></h3>
<p>It's simple to call a netidx rpc with command line tools, the browser,
or programatically. To create a new playback session with default
values just write <code>null</code> to <code>publish-base/session</code>. e.g.</p>
<pre><code>netidx subscriber &lt;&lt;EOF
WRITE|/solar/archive/session|string|null
EOF
/solar/archive/session|string|ef93a9dce21f40c49f5888e64964f93f
</code></pre>
<p>We just created a new playback session called
ef93a9dce21f40c49f5888e64964f93f, we can see that the recorder
published some new things there,</p>
<pre><code>$ netidx resolver list /solar/archive/ef93a9dce21f40c49f5888e64964f93f/*
/solar/archive/ef93a9dce21f40c49f5888e64964f93f/data
/solar/archive/ef93a9dce21f40c49f5888e64964f93f/cluster
/solar/archive/ef93a9dce21f40c49f5888e64964f93f/control
</code></pre>
<p>If we want to pass some arguments to the rpc so our session will be
setup how we like by default we can do that as well, e.g.</p>
<pre><code>netidx subscriber &lt;&lt;EOF
CALL|/solar/archive/session|start="-3d",speed=2
EOF
CALLED|/archive/session|"ef93a9dce21f40c49f5888e64964f93f"
</code></pre>
<p>Now our new session would be setup to start 3 days ago, and playback
at 2x speed.</p>
<h3 id="playback-controls"><a class="header" href="#playback-controls">Playback Controls</a></h3>
<p>Once we've created a new session the recorder publishes some controls
under the control directory. The five controls both tell you the state
of the playback session, and allow you to control it. They are,</p>
<ul>
<li><code>start</code>: The timestamp you want playback to start at, or Unbounded
for the beginning of the archive. This will always display
Unbounded, or a timestamp, but it in addition to those two values it
accepts writes in the form of offsets from the current time,
e.g. -3d would set the start to 3 days ago. It accepts offsets
[+-]N[yMdhms] where N is a number. y - years, M - months, d - days,
h - hours, m - minutes, s - seconds.</li>
<li><code>end</code>: Just like start except that Unbounded, or a time in the
future means that when playback reaches the end of the archive it
will switch mode to tail. In tail mode it will just repeat data as
it comes in. In the case that end is in the future, but not
unbounded, it will stop when the future time is reached.</li>
<li><code>pos</code>: The current position, always displayed as a timestamp unless
there is no data in the archive. Pos accepts writes in the form of
timestamps, offsets from the current time (like start and end), and
[+-]1-128 batches. e.g. -10 would seek back exactly 10 update
batches, +100 would seek forward exactly 100 update batches.</li>
<li><code>speed</code>: The playback speed as a fraction of real time, or
Unlimited. In the case of Unlimited the archive is played as fast as
it can be read, encoded, and sent. Otherwise the recorder tries to
play back the archive at aproximately the specified fraction of real
time. This will not be perfect, because timing things on computers
is hard, but it tries to come close.</li>
<li><code>state</code>: this is either play, pause or tail, and it accepts writes
of any state and will change to the requested state if possible.</li>
</ul>
<p>Since the controls also include a small amount of documentation meant
to render as a table, the actual value that you read from/write to is
<code>publish-base/session-id/control/name-of-control/current</code>.</p>
<h3 id="data"><a class="header" href="#data">Data</a></h3>
<p>Once the session is set up the data, whatever it may be, appears under
<code>publish-base/data</code>. Every path that ever appears in the archive is
published from the beginning, however, if at the current <code>pos</code> that
path didn't have a value, then it will be set to <code>null</code>. This is a
slightly unfortunate compromise, as it's not possible to tell the
difference between a path that wasn't available, and one that was
intentionally set to null. When you start the playback values will be
updated as they were recorded, including replicating the observed
batching.</p>
<h3 id="deleting-a-playback-session"><a class="header" href="#deleting-a-playback-session">Deleting a Playback Session</a></h3>
<p>Simply stop subscribing to any value or control in the session and the
recorder will garbage collect it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="container"><a class="header" href="#container">Container</a></h1>
<p>The container is a persistent store for netidx values, a bit like a
pasteboard, or a nosql database. At startup it reads and publishes all
the data in it's database, and then waits for user interaction. When
an authorized user writes to one of it's published values it updates
that value in the database, and then updates the published value for
subscribers. To allow creation of new values it installs a default
publisher at one or more user chosen roots. If an authorized user
subscribes to a path that isn't in the database, then it will add a
new empty value to the database at that path. The user can then write
whatever value they wish to the new path, and it will persist in the
database.</p>
<p>As well as storing values, cells can be bscript formulas. In that case
instead of storing the cell value in the database the formula text is
stored, and the published value will be whatever the formula evaluates
to. An additional bscript expression can be added to a formula cell to
define what happens when it is written to, so a formula cell can form
a proper lens. The entire bscript api is supported, except for the
browser specific functions event, confirm, and navigate. There are two
additional functions specific to the container. ref and rel. ref
refers to a path that must be hosted by the same container, in
exchange for this restriction it's quite a bit faster than load. rel
takes advantage of the fact that trees can often be seen as tables to
allow you to get the path of a cell by offset to current cell. For
example rel(-1) gets the path of the cell in the same row, but 1
column to the left. rel(1) goes 1 column to the right. rel(-1, 0) gets
the path to the cell in the same column but 1 row up.</p>
<p>Because bscript is an incremental language it automatically recomputes
the value of a formula when something it depends on changes. Using the
helpers to create "sheets" you can create something a lot like a
google sheet or cloud excel sheet, multiple users can edit and view it
concurrently while keeping a consistent view. With a little browser
bscript you can even make it look like a spreadsheet.</p>
<p>Probably more interesting than replicating a cloud sheet is that you
aren't limited to "spreadsheet like things", you can use bscript
formulas to e.g. select and project data from elsewhere in netidx,
combine it with local data and compute interesting things. However the
most important difference of all is that unlike a spreadsheet the
things you compute in a container sheet are not locked into some gui,
they are available to be consumed by any authorized subscriber on the
network, just like anything else in netidx.</p>
<h2 id="administration-1"><a class="header" href="#administration-1">Administration</a></h2>
<h3 id="args-2"><a class="header" href="#args-2">Args</a></h3>
<ul>
<li><code>--compress</code>: enable zstd compression</li>
<li><code>--compress-level &lt;0-9&gt;</code>: set the zstd compression level</li>
<li><code>--db</code>: the path to the db</li>
<li><code>--api-path &lt;path&gt;</code>: where to publish the rpc interface and db stats</li>
<li><code>-b, --bind &lt;spec&gt;</code>: the ip specification to bind to</li>
<li><code>-a, --auth</code>: the auth mechanism, anonymous, local, or krb5</li>
<li><code>--spn &lt;spn&gt;</code>: the kerberos service principal name to publish as</li>
<li><code>--cache-size &lt;bytes&gt;</code>: the database cache size in bytes, default 1 gigabyte</li>
<li><code>--timeout &lt;seconds&gt;</code>: the time after which a slow subscriber will be disconnected 0 for no timeout</li>
<li><code>--sparse</code>: don't even advertise paths in the db</li>
</ul>
<h3 id="a-note-about-memory-use"><a class="header" href="#a-note-about-memory-use">A Note About Memory Use</a></h3>
<p>There were some lies in the introduction. If you're a seasoned
sysadmin or DBA you might have cringed when you read "reads and
publishes all the data in it's database". From the point of view of
the casual user that is what happens, but the reality is more complex,
and a lot more efficient. The container does scan the database at
startup, but it doesn't immediately publish anything except
formulas. Instead it advertises all of the paths it has, which is a
middle way between just becoming a default publisher, and a full
publish. It tells the resolver server every path it could publish, but
doesn't actually publish any of them until right before a subscriber
asks for one. That means that it doesn't keep any of the data in the
database in memory unless there is a client subscribed to it, and as
soon as no client is subscribed it stops publishing and evicts the
data from memory (though the db layer may cache it for a while). You
can even turn off advertisements if you want to publish a truly huge
data set. Though, in that case the user is going to have to know the
name of the data they want, there will be no way to browse it, or
search it, only data that someone is subscribed to will even show up
in the resolver server.</p>
<h2 id="rpcs"><a class="header" href="#rpcs">RPCs</a></h2>
<p>The container has an extensive rpc api, and that is the only way to do
many things e.g. make a cell a formula, or add a root. Under it's
api-path it also publishes information about it's status, such as
whether the background database is currently busy, and how many write
transactions are queued.</p>
<h3 id="add-root"><a class="header" href="#add-root">add-root</a></h3>
<pre><code>add-root(path)
</code></pre>
<p>Adds <code>path</code> as a root. This will cause the container to become a
default publisher for the subtree rooted at <code>path</code>. At least 1 root
must be added before the container will do anything. Roots can be
completely disjoint, however it is an error to add a root under an
existing root. It is not an error to add a new root above existing
roots, but for tidiness you should probably remove the child roots
after adding the parent.</p>
<p>e.g.</p>
<pre><code>add-root("/solar/gui");
add-root("/tmp");
</code></pre>
<p>would make the container responsible for /tmp, and /solar/gui</p>
<h3 id="remove-root"><a class="header" href="#remove-root">remove-root</a></h3>
<pre><code>remove-root(path)
</code></pre>
<p>Removes <code>path</code> as a root. This will cause the container to stop being
a default publisher for the subtree rooted at <code>path</code>. If the root you
are removing has no parent root, then all the data under it will also
be removed.</p>
<h3 id="lock-subtree"><a class="header" href="#lock-subtree">lock-subtree</a></h3>
<pre><code>lock-subtree(path)
</code></pre>
<p>By default the container creates a free for all environment, any
authorized user can subscribe to any path they like that is under a
root and it will be created if it doesn't exist. This mode of
operation has it's uses, but sometimes it just creates unnecessary
chaos. lock-subtree turns off automatic creation by the default
publisher under the specified subtree. In a locked subtree, only paths
that already exist in the database, or are explicitly specified in RPC
calls can be created.</p>
<p>The lock is hierarchical, the lock state flows down the tree, so
you can express more complex situations if you need to. For example consider,</p>
<pre><code>path      locked
----      ------
/tmp      true
/tmp/ffa  false
</code></pre>
<p>Everything under /tmp is locked, so you can't accidentally create e.g.
/tmp/foo, but everything under /tmp/ffa is unlocked, so it is once
again a free for all. Later we could lock /tmp/ffa/important-thing and
that would again be not a free for all. You get to the above table by
making two rpc calls.</p>
<p>e.g.</p>
<pre><code>lock-subtree(/tmp)
unlock-subtree(/tmp/ffa)
</code></pre>
<h3 id="unlock-subtree"><a class="header" href="#unlock-subtree">unlock-subtree</a></h3>
<pre><code>unlock-subtree(path)
</code></pre>
<p>See lock-subtree. unlock-subtree either removes a subtree completely
from being locked, or marks a subtree as locally unlocked.</p>
<h3 id="set-data"><a class="header" href="#set-data">set-data</a></h3>
<pre><code>set-data(path, value)
</code></pre>
<p>Make the specified cell(s) plain data, and optionally set their
value(s). path and value may be specified multiple times and doing so
will cause multiple paths to be set. value is optional, and if
omitted, cells will be set to null. If any of the specified cells are
formula cells, they will be converted to data cells and the formulas
will be deleted. If any of the specified cells do not exist in the
database they will be added, regardless of the locked state of their
subtree.</p>
<p>e.g.</p>
<pre><code>set-data(
    path=string:/tmp/the-cake,
    value=bool:false, 
    path=string:/tmp/is-a-lie,
    value=bool:true
)
</code></pre>
<h3 id="set-formula"><a class="header" href="#set-formula">set-formula</a></h3>
<pre><code>set-formula(path, formula, on-write)
</code></pre>
<p>Make the specified cell(s) formula cells. If they are currently data
cells, delete the data and convert them to formula cells. If they
don't currently exist create them regardless of the locked state of
their subtree.</p>
<p>path may be specified multiple times to operate on multiple cells in
one call. formula, and on-write may be specified zero or more
times. If formula and/or on write are not specified they will be set
to null.</p>
<p>after <code>set-formula</code> has been called for a cell, the formula text and
the on-write formula text will be published under <code>path/.formula</code> and
<code>path/.on-write</code>. The formula and the on-write formula may be edited
by writing to those paths as well as by calling this rpc.</p>
<p>e.g.</p>
<pre><code>set-formula(
    path=string:/tmp/sheet/00/01,
    path=string:/tmp/sheet/01/01,
    path=string:/tmp/sheet/02/01,
    path=string:/tmp/sheet/03/01,
    formula=string:sum(ref(rel(-1))\, 1)
)
</code></pre>
<p>set the first 4 rows of the second column of /tmp/sheet to be the
formula <code>sum(ref(rel(-1)), 1)</code>, which will add 1 to the corresponding
cell in the first column.</p>
<h3 id="delete"><a class="header" href="#delete">delete</a></h3>
<pre><code>delete(path)
</code></pre>
<p>remove the specified path(s) from the database, whether data or
formula, and stop publishing them. Any current subscribers will be
unsubscribed. If the subtree isn't locked, durable subscribers may
readd the path(s) by immediately resubscribing (but the data is gone).</p>
<h3 id="delete-subtree"><a class="header" href="#delete-subtree">delete-subtree</a></h3>
<pre><code>delete-subtree(path)
</code></pre>
<p>remove all the data and formulas under the specified paths(s). There
is no way to undo this, so you may want to restrict access to
administrators.</p>
<h3 id="create-sheet"><a class="header" href="#create-sheet">create-sheet</a></h3>
<pre><code>create-sheet(path, rows, columns, max-rows, max-columns, lock)
</code></pre>
<p>This is a helper function to create a "spreadsheet like sheet" at the
specified path. It will create a tree structure that will render as a
table in the browser with numbered rows and columns,
e.g. /tmp/sheet/001/01 for row 1 column 1. rows is the initial number
of rows, and columns is the initial number of columns. max-rows and
max-columns are optional, and are used to set the string width of the
number components, if they aren't specified they will be computed from
rows and columns. While it is possible to exceed these values in a
sheet, as tree size is only limited by memory and disk space, the
sorting will be wrong if you do. lock is optional, default true, if
true the subtree of the table will be automatically locked.</p>
<p>e.g.</p>
<pre><code>create-sheet(path=string:/tmp/sheet,rows=u64:1000000,columns=u64:10)
</code></pre>
<p>Would pre create a pretty large sheet. This will take a while and will
use some disk space, so you may want to use add-sheet-rows and/or
add-sheet-columns to fill in as you go. In case know we only need 10
columns, but we might need up to 1 million rows then we could do,</p>
<p>e.g.</p>
<pre><code>create-sheet(
    path=string:/tmp/sheet,
    rows=u64:1000,
    columns=u64:10,
    max-rows=u64:1000000
)
</code></pre>
<p>and then we can <code>add-sheet-rows</code> in batches of 1k or more up to 1m.</p>
<h3 id="add-sheet-rows"><a class="header" href="#add-sheet-rows">add-sheet-rows</a></h3>
<pre><code>add-sheet-rows(path, rows)
</code></pre>
<p>add rows to a previously created sheet</p>
<h3 id="add-sheet-columns"><a class="header" href="#add-sheet-columns">add-sheet-columns</a></h3>
<pre><code>add-sheet-columns(path, columns)
</code></pre>
<p>add columns to a previously created sheet</p>
<h3 id="delete-sheet-rows"><a class="header" href="#delete-sheet-rows">delete-sheet-rows</a></h3>
<pre><code>delete-sheet-rows(path, rows)
</code></pre>
<p>remove the specified number of rows from the end of sheet. If you want
to delete a specific row you can just just <code>delete-subtree</code>.</p>
<h3 id="delete-sheet-columns"><a class="header" href="#delete-sheet-columns">delete-sheet-columns</a></h3>
<pre><code>delete-sheet-columns(path, columns)
</code></pre>
<p>remove the specified number of columns from the end of sheet</p>
<h3 id="create-table"><a class="header" href="#create-table">create-table</a></h3>
<pre><code>create-table(path, row, column, lock)
</code></pre>
<p>Helper function to create a tree structure that will render in the
browser as a table, and will have the specified row(s) and
column(s). row and column must be specified one or more times.</p>
<p>e.g.</p>
<pre><code>create-table(
    path=string:/tmp/table,
    row=string:01,
    row=string:02,
    row=string:03
    column=string:widget,
    column=string:implemented
)
</code></pre>
<p>will create a table with two columns "widget" and "implemented" and
three rows "01", "02", and "03".</p>
<h3 id="add-table-rows"><a class="header" href="#add-table-rows">add-table-rows</a></h3>
<pre><code>add-table-rows(path, row)
</code></pre>
<p>add the row(s) to the specified table.</p>
<h3 id="add-table-columns"><a class="header" href="#add-table-columns">add-table-columns</a></h3>
<pre><code>add-table-columns(path, column)
</code></pre>
<p>add the column(s) to the specified table.</p>
<h3 id="delete-table-rows"><a class="header" href="#delete-table-rows">delete-table-rows</a></h3>
<pre><code>delete-table-rows(path, row)
</code></pre>
<p>delete the specified row(s) from the table</p>
<h3 id="delete-table-columns"><a class="header" href="#delete-table-columns">delete-table-columns</a></h3>
<pre><code>delete-table-columns(path, column)
</code></pre>
<p>delete the specified column(s) from the table</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="activation"><a class="header" href="#activation">Activation</a></h1>
<p>Activation is a process manager for netidx somewhat like systemd or
dbus activation. It's core function is to install a default publisher
at configured trigger paths, and then start a process whenever someone
tries to subscribe to anything under the trigger path. Publishers for
many kinds of services can thus be started on demand, and can shut
down when no one is using them. This can save resources, and it can
also simplify starting up all the "moving parts" of a complex service.</p>
<p>In fact a convenient way to run netidx on both a server or a
workstation is to configure all your netidx applications, including
the resolver server, as activation units, and then start the
activation server on startup with systemd. There are a number of
benefits to this, including, single command start/stop of everything
netidx, unified logs, unified setting of environment variables like
RUST_LOG, and resource control via cgroups.</p>
<h2 id="units"><a class="header" href="#units">Units</a></h2>
<p>Each managed process is configured with a unit file. Unit files are
placed in a directory, by default <code>/etc/netidx/activation</code> or
<code>~/.config/netidx/activation</code>. The user specific directory will take
prescidence if it exists.</p>
<p>Here is an example activation unit triggered on access to any path
under <code>/local/music</code></p>
<pre><code class="language-json">{
  "trigger": {
    "OnAccess": [
      "/local/music"
    ]
  },
  "process": {
    "exe": "/home/eric/.cargo/bin/demoscene",
    "args": [
      "--base",
      "/local/music",
      "--library",
      "/home/eric/mus"
    ]
  }
}
</code></pre>
<p>Many optional fields exist, here is a list of all possible options and
their function.</p>
<ul>
<li><code>trigger</code>: either OnAccess followed by a list of paths, or OnStart.
<ul>
<li>
<p><code>OnAccess</code> will start the process whenever a subscriber tries to
subscribe to any path under one of the trigger paths. Once the
process starts the activation server will remove the default
publisher from the trigger paths. If the unit's process dies, the
activation server will readd the default publishers to the trigger
paths, but it will only start the process again if a subscriber
tries to access one of the trigger paths. So unused services can
shut down and will stay shut down until someone wants them.</p>
<p>It is an error for multiple units to have overlapping triggers.</p>
</li>
<li>
<p><code>OnStart</code> will start the process when the activation server starts,
and if it dies will restart it according to the restart directive
of the process config.</p>
</li>
</ul>
</li>
<li><code>process</code>: The process config defines what to start, and gives options
to control it's environment and how it should be restarted if it
stops.
<ul>
<li><code>exe</code>: The path to the executable to start. This is the only
required field of the process config. The specified file must
exist and must be executable when the unit is loaded otherwise
loading the unit will fail.</li>
<li><code>args</code>: A list of arguments to the executable. default [].</li>
<li><code>working_directory</code>: Path to the directory where the executable will
be started. default the working directory of the activation
server.</li>
<li><code>uid</code>: The numeric user id to run the process as. default the uid of
the activation server.</li>
<li><code>gid</code>: The numeric group id to run the process as. default the gid
of the activation server.</li>
<li><code>restart</code>: Yes, No, or RateLimited with an f64 number of seconds
delay. Default <code>"RateLimited": 1.</code>.</li>
<li><code>stdin</code>: The path to the file, pipe, etc that
will be set as the processes stdin. default, inherited from the
activation server.</li>
<li><code>stdout</code>: The path to the file, pipe, etc that will be set as the
processes stdout. default, inherited from the activation server.</li>
<li><code>stderr</code>: The path to the file, pipe, etc that will be set as the
processes stderr. default, inherited from the activation server.</li>
<li><code>environment</code>: either Inherit followed by a list of environment
mappings to be overridden or replace followed by the full list of
environment mappings. e.g.
<pre><code class="language-json">"Inherit": {
  "PATH": "/bin:/usr/bin",
  "TERM": "xterm",
  ...
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="signals"><a class="header" href="#signals">Signals</a></h2>
<p>Sending <code>SIGHUP</code> to the running activation server will cause it to
reread it's unit directory. This may trigger processes (for example a
newly added OnStart process) to start up immediatly. If unit files are
removed, their corresponding processes will be stopped upon unit
directory reread. If process config properties are changed for an
existing unit, any running process will NOT be restarted, however new
configuration directives will take effect if the process dies and is
triggered. For example if args is changed for a unit that is running,
and it later dies and is triggered again it will be started with the
new args.</p>
<p>On receiving <code>SIGQUIT</code>, <code>SIGINT</code>, or <code>SIGTERM</code>, the activation server
will stop all the processes it is managing before shutting down
itself. Managed processes are first sent <code>SIGTERM</code>, but if they don't
shut down within 30 seconds they are killed with <code>SIGKILL</code>.</p>
<h2 id="args-3"><a class="header" href="#args-3">Args</a></h2>
<ul>
<li><code>-f, --foreground</code>: don't daemonize</li>
<li><code>-a, --auth</code>: auth mechanism. either anonymous, local, or
krb5. default krb5.</li>
<li><code>-b, --bind</code>: bind address.</li>
<li><code>-c, --config</code>: path to the netidx client config</li>
<li><code>--pid-file</code>: path to the pid file you want the activation server to
write. default no pid file.</li>
<li><code>--spn</code>: the spn of the activation server. only relevant if auth =
krb5</li>
<li><code>-u, --units</code>: the path to the directory containing unit
files. default <code>/etc/netidx/activation</code> or
<code>~/.config/netidx/activation</code></li>
<li><code>--upn</code>: the upn to use when connecting to the resolver, only valid
if auth = krb5. default the current user.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stress-test-tool"><a class="header" href="#stress-test-tool">Stress Test Tool</a></h1>
<p>The stress test tool is mostly for debug and development of netidx
itself. The stress publisher publishes a configurably sized table, and
updates each value after a configurable timeout. The stress subscriber
subscribes to every value in the table published by the stress
publisher, and prints throughput statistics to stdout.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-into-an-existing-system"><a class="header" href="#integration-into-an-existing-system">Integration Into an Existing System</a></h1>
<p>Suppose we have a small daemon that we run on many computers on our
network, and it knows many things about them, and does many things. I
won't specify exactly what it does or everything it knows because
that's irrelevant to the example. However suppose one of the things it
knows is the current CPU temperature of the machine it's running on,
and we would like access to that data. We heard about this new netidx
thing, and we'd like to try it out on this small and not very
important case. What code do we need to add to our daemon, and what
options do we have for using the data?</p>
<p>We can modify our Cargo.toml to include netidx, and then add a small
self contained module, publisher.rs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyhow::Result;
use netidx::{
    config::Config,
    path::Path,
    publisher::{Publisher, Val, Value},
    resolver_client::DesiredAuth,
};

pub struct HwPub {
    publisher: Publisher,
    cpu_temp: Val,
}

impl HwPub {
    pub async fn new(host: &amp;str, current: f64) -&gt; Result&lt;HwPub&gt; {
        // load the site cluster config from the path in the
        // environment variable NETIDX_CFG, or from
        // dirs::config_dir()/netidx/client.json if the environment
        // variable isn't specified, or from ~/.netidx.json if the
        // previous file isn't present. Note this uses the cross
        // platform dirs library, so yes, it does something reasonable
        // on windows.
        let cfg = Config::load_default()?;

        // for this small service we don't need authentication
        let auth = DesiredAuth::Anonymous;

        // listen on any unique address matching 192.168.0.0/24. If
        // our network was large and complex we might need to make
        // this a passed in configuration option, but lets assume it's
        // simple.
        let publisher = Publisher::new(cfg, auth, "192.168.0.0/24".parse()?).await?;

        // We're publishing stats about hardware here, so lets put it
        // in /hw/hostname/cpu-temp, that way we keep everything nice
        // and organized.
        let path = Path::from(format!("/hw/{}/cpu-temp", host));
        let cpu_temp = publisher.publish(path, Value::F64(current))?;

        // Wait for the publish operation to be sent to the resolver
        // server.
        publisher.flushed().await;
        Ok(HwPub { publisher, cpu_temp })
    }

    pub async fn update(&amp;self, current: f64) {
        // start a new batch of updates. 
        let mut batch = self.publisher.start_batch();

        // queue the current cpu-temp in the batch
        self.cpu_temp.update(&amp;mut batch, Value::F64(current));

        // send the updated value out to subscribers
        batch.commit(None).await
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now all we would need to do is create a HwPub on startup, and call
HwPub::update whenever we learn about a new cpu temperature value. Of
course we also need to deploy a resolver server, and distribute a
cluster config to each machine that needs one, that will be covered in
the administration section.</p>
<h2 id="using-the-data-we-just-published"><a class="header" href="#using-the-data-we-just-published">Using the Data We Just Published</a></h2>
<p>So now that we have our data in netidx, what are our options for
consuming it? The first option, and often a very good one for a lot of
applications is the shell. The netidx command line tools are designed
to make this interaction easy, here's an example of how we might use
the data.</p>
<pre><code class="language-bash">#! /bin/bash

netidx subscriber -a anonymous $(netidx resolver -a anonymous list '/hw/*/cpu-temp') | \
while IFS='|' read path typ temp; do
    IFS='/' pparts=($path)
    if ((temp &gt; 75)); then
        echo "host: ${pparts[2]} cpu tmp is too high: ${temp}"
    fi
done
</code></pre>
<p>Of course we can hook any logic we want into this, the shell is a very
powerful tool after all. For example one thing we might want do is
modify this script slightly, filter the entries with cpu temps that
are too high, and then publish the temperature and the timestamp when
it was observed.</p>
<pre><code class="language-bash">#! /bin/bash

netidx subscriber -a anonymous $(netidx resolver -a anonymous list '/hw/*/cpu-temp') | \
while IFS='|' read path typ temp; do
    IFS='/' pparts=($path)
    if ((temp &gt; 75)); then
        echo "/hw/${pparts[2]}/overtemp-ts|string|$(date)"
        echo "/hw/${pparts[2]}/overtemp|f64|$temp"
    fi
done | \
netidx publisher -a anonymous --bind 192.168.0.0/24
</code></pre>
<p>Now we've done something very interesting, we took some data out of
netidx, did a computation on it, and published the result into the
same namespace. We can now subscribe to e.g. <code>/hw/krusty/overtemp-ts</code>
and we will know when that machine last went over temperature. To a
user looking at this namespace in the browser (more on that later)
there is no indication that the over temp data comes from a separate
process, on a separate machine, written by a separate person. It all
just fits together seamlessly as if it was one application.</p>
<p>There is actually a problem here, in that, the above code will not do
quite what you might want it to do. Someone might, for example, want
to write the following additional script.</p>
<pre><code class="language-bash">#! /bin/bash

netidx subscriber -a anonymous $(netidx resolver -a anonymous list '/hw/*/overtemp-ts') | \
while IFS='|' read path typ temp; do
    IFS='/' pparts=($path)
    ring-very-loud-alarm ${pparts[2]}
done
</code></pre>
<p>To ring a very loud alarm when an over temp event is detected. This
would in fact work, it just would not be as timely as the author might
expect. The reason is that the subscriber practices linear backoff
when it's instructed to subscribe to a path that doesn't exist. This
is a good practice, in general it reduces the cost of mistakes on the
entire system, but in this case it could result in getting the alarm
minutes, hours, or longer after you should. The good news is there is
a simple solution, we just need to publish all the paths from the
start, but fill them will null until the event actually happens (and
change the above code to ignore the null). That way the subscription
will be successful right away, and the alarm will sound immediately
after the event is detected. So lets change the code ...</p>
<pre><code class="language-bash">#! /bin/bash

declare -A HOSTS
netidx resolver -a anonymous list -w '/hw/*/cpu-temp' | \
    sed -u -e 's/^/ADD|/' | \
    netidx subscriber -a anonymous | \
    while IFS='|' read path typ temp
    do
        IFS='/' pparts=($path)
        temp=$(sed -e 's/\.[0-9]*//' &lt;&lt;&lt; "$temp") # strip the fractional part, if any
        host=${pparts[2]}
        if ((temp &gt; 75)); then
            HOSTS[$host]=$host
            echo "/hw/${host}/overtemp-ts|string|$(date)"
            echo "/hw/${host}/overtemp|f64|$temp"
        elif test -z "${HOSTS[$host]}"; then
            HOSTS[$host]=$host
            echo "/hw/${host}/overtemp-ts|null"
            echo "/hw/${host}/overtemp|null"
        fi
    done | netidx publisher -a anonymous --bind 192.168.0.0/24
</code></pre>
<p>We use <code>resolver list -w</code> to list all paths that match
<code>/hw/*/cpu-temp</code>, and watch for new ones that might appear later. We
take that output, which is just a list of paths, and use sed to
prepend <code>ADD|</code> to it, which makes it a valid subscribe request for
<code>netidx subscriber</code>. We then process the resulting cpu temperature
records. We check for over temp, and we store each host in an
associative array. If this is the first time we've seen a given host,
then we set it's initial <code>overtemp-ts</code> and <code>overtemp</code> to null,
otherwise we don't do anything unless it's actually too hot. Even
though it's only a little longer, this shell program has a number of
advantages over the previous version.</p>
<ul>
<li>It will automatically start checking the cpu temp of new hosts as
they are added</li>
<li>It will always publish a row for every host, but will fill it with
null if it has never seen that host over temp. This allows clients
to subscribe to the overtemp value and receive a timely notification
when a host goes over temperature, and it's also nicer to look at in
the browser.</li>
<li>It handles the fractional part of the temperature properly for the
shell, which can't do floating point math (in this case we don't
care)</li>
</ul>
<h2 id="or-maybe-shell-is-not-your-jam"><a class="header" href="#or-maybe-shell-is-not-your-jam">Or Maybe Shell is Not Your Jam</a></h2>
<p>It's entirely possible that thinking about the above solution makes
you shiver and reinforces for you that nothing should ever be written
in shell. In that case it's perfectly possible to do the same thing in
rust.</p>
<pre><pre class="playground"><code class="language-rust">use anyhow::Result;
use chrono::prelude::*;
use futures::{
    channel::mpsc::{channel, Sender},
    prelude::*,
};
use netidx::{
    chars::Chars,
    config::Config,
    path::Path,
    pool::Pooled,
    publisher::{self, Publisher, Value},
    resolver_client::{DesiredAuth, ChangeTracker, Glob, GlobSet},
    subscriber::{self, Event, SubId, Subscriber, UpdatesFlags},
};
use std::{
    collections::{HashMap, HashSet},
    iter,
    sync::{Arc, Mutex},
    time::Duration,
};
use tokio::{task, time};

struct Temp {
    // we need to hang onto this reference to keep the subscription alive
    _current: subscriber::Dval, 
    timestamp: publisher::Val,
    temperature: publisher::Val,
}

async fn watch_hosts(
    subscriber: Subscriber,
    publisher: Publisher,
    tx_current: Sender&lt;Pooled&lt;Vec&lt;(SubId, Event)&gt;&gt;&gt;,
    temps: Arc&lt;Mutex&lt;HashMap&lt;SubId, Temp&gt;&gt;&gt;,
) -&gt; Result&lt;()&gt; {
    // we keep track of all the hosts we've already seen, so we don't
    // publish an overtemp record for any host more than once.
    let mut all_hosts = HashSet::new();
    // we will talk directly to the resolver server cluster. The
    // ChangeTracker will allow us to efficiently ask if anything new
    // has been published under the /hw subtree. If anything has, then
    // we will list everything in that subtree that matches the glob
    // /hw/*/cpu-temp.
    let resolver = subscriber.resolver();
    let mut ct = ChangeTracker::new(Path::from("/hw"));
    let pat = GlobSet::new(true, iter::once(Glob::new(Chars::from("/hw/*/cpu-temp"))?))?;
    loop {
        if resolver.check_changed(&amp;mut ct).await? {
            let mut batches = resolver.list_matching(&amp;pat).await?;
            for mut batch in batches.drain(..) {
                for path in batch.drain(..) {
                    if let Some(host) = path.split('/').nth(2).map(String::from) {
                        if !all_hosts.contains(&amp;host) {
                            // lock the temps table now to ensure the
                            // main loop can't see an update for an
                            // entry that isn't there yet.
                            let mut temps = temps.lock().unwrap();
                            // subscribe and register to receive updates
                            let current = subscriber.durable_subscribe(path.clone());
                            current.updates(
                                UpdatesFlags::BEGIN_WITH_LAST,
                                tx_current.clone(),
                            );
                            // publish the overtemp records, both with
                            // initial values of Null
                            let timestamp = publisher.publish(
                                Path::from(format!("/hw/{}/overtemp-ts", host)),
                                Value::Null,
                            )?;
                            let temperature = publisher.publish(
                                Path::from(format!("/hw/{}/overtemp", host)),
                                Value::Null,
                            )?;
                            // record that we've seen the host, and
                            // add the published overtemp record to
                            // the temps table.
                            all_hosts.insert(host);
                            temps.insert(
                                current.id(),
                                Temp { _current: current, timestamp, temperature },
                            );
                        }
                    }
                }
            }
        }
        // wait for anything new we've published to be flushed to the
        // resolver server.
        publisher.flushed().await;
        // wait 1 second before polling the resolver server again
        time::sleep(Duration::from_secs(1)).await
    }
}

#[tokio::main]
pub async fn main() -&gt; Result&lt;()&gt; {
    // load the default netidx config
    let config = Config::load_default()?;
    let auth = DesiredAuth::Krb5 {upn: None, spn: Some("publish/blackbird.ryu-oh.org@RYU-OH.ORG".into())};
    // setup subscriber and publisher
    let subscriber = Subscriber::new(config.clone(), auth.clone())?;
    let publisher = Publisher::new(config, auth, "192.168.0.0/24".parse()?).await?;
    let (tx_current, mut rx_current) = channel(3);
    // this is where we'll store our published overtemp record for each host
    let temps: Arc&lt;Mutex&lt;HashMap&lt;SubId, Temp&gt;&gt;&gt; = Arc::new(Mutex::new(HashMap::new()));
    // start an async task to watch for new hosts publishing cpu-temp records
    task::spawn(watch_hosts(
        subscriber.clone(),
        publisher.clone(),
        tx_current.clone(),
        temps.clone(),
    ));
    while let Some(mut batch) = rx_current.next().await {
        let mut updates = publisher.start_batch();
        {
            let temps = temps.lock().unwrap();
            for (id, ev) in batch.drain(..) {
                match ev {
                    Event::Unsubscribed =&gt; (), // Subscriber will resubscribe automatically
                    Event::Update(v) =&gt; {
                        if let Ok(temp) = v.cast_to::&lt;f64&gt;() {
                            if temp &gt; 75. {
                                let tr = &amp;temps[&amp;id];
                                tr.timestamp.update(&amp;mut updates, Value::DateTime(Utc::now()));
                                tr.temperature.update(&amp;mut updates, Value::F64(temp));
                            }
                        }
                    }
                }
            }
        } // release the lock before we do any async operations
        if updates.len() &gt; 0 {
            updates.commit(None).await
        }
    }
    Ok(())
}</code></pre></pre>
<p>This does almost exactly the same thing as the shell script, the only
semantic difference being that it sends an actual DateTime value for
the timestamp instead of a string, which would certainly make life
easier for anyone using this data, not to mention it's more
efficient.</p>
<h2 id="but-i-just-want-to-look-at-my-data"><a class="header" href="#but-i-just-want-to-look-at-my-data">But I Just Want to Look at My Data</a></h2>
<p>Up to now we've covered using the data in various kinds of programs,
but what if you just want to look at it. For that you have two
choices, you can write a custom tool that presents your data exactly
the way you want, or you can use the netidx browser. A custom tool
will always give you more control, but the browser is designed to be
pretty flexible, and it allows you to get to an ok looking solution
really fast. In the case of the data we've been discussing in this
chapter, you get something pretty nice to look at without doing
anything at all.</p>
<p><img src="examples/small-example-table.png" alt="The Browser rendering a table" /></p>
<p>So what's going on here, how did we get a nice looking table out of a
tree? When asked to navigate to a path the browser looks for two kinds
of regular structures, and will draw something appropriate based on
it's findings. One kind is a tree where the 1st level children
themselves have a regular set of children. By regular I mean, with the
same name. In the example we have</p>
<pre><code>/hw/um01-ta07-09/cpu-temp
/hw/um01-ta07-09/overtemp-ts
/hw/um01-ta07-09/overtemp
</code></pre>
<p>But all the 1st level nodes have the same children, so the pattern is,</p>
<pre><code>/hw/${host}/cpu-temp
/hw/${host}/overtemp-ts
/hw/${host}/overtemp
</code></pre>
<p>The browser discovers that regularity, and elects to make a row for
each $host, and a column for each child of $host. In our case, the
data is perfectly regular, and so we end up with a fully populated
table with 3 columns, and a row for each host.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="browser"><a class="header" href="#browser">Browser</a></h1>
<p>The browser is a graphical tool that visualizes the contents of
netidx, it allows users to navigate to places of interest, view data
in tabular or vector form, and construct applications with custom
views and BScript.</p>
<p>Depending on the structure of a subtree the browser draws either a
vector,</p>
<p><img src="browser/./browser-vector-mode.png" alt="Vector mode" /></p>
<p>or a table,</p>
<p><img src="browser/./browser-components-tour.png" alt="Table mode" /></p>
<p>The various components highlighted in red are,</p>
<ol>
<li>The path of the currently visualized subtree. To navigate, you can
click on any of the individual components, e.g. click the <code>/</code> to
navigate to the root, and you can refresh the current view by
clicking the link to the current path, <code>bench</code> in this case. If
you're viewing a custom view stored in a file, then this will be
indicated by the current path changing to
e.g. <code>file://somwhere/in/the/file/system</code>.</li>
<li>The gutter displays the path of the currently selected cell, or, in
a custom view it displays the BScript bound to the currently
selected or hovered object.</li>
<li>Design mode button, click to enter design mode. This will display
the design of the current view, and allow you to edit it. This will
be covered in detail in the next section.</li>
<li>The currently selected cell in a table is highlighed. If you want
to write to the currently selected cell, you can press Ctrl+w, and
a write dialog will appear.</li>
<li>The menu button.</li>
</ol>
<p>You can enter a subtree by double clicking anywhere in a row. To go
up, use the path links as described in 1. You can also go directly to
a specific path by using <code>go</code> from the menu.</p>
<p>A subtree will be visualized as a table if it contains a regular
structure of leaf nodes that are named the same thing for multiple
parents, e.g.</p>
<pre><code>/base/row0/col0
/base/row0/col1
...
/base/rowN/col0
/base/rowN/col1
</code></pre>
<p>This will automatically visualize as a table with N rows named <code>row0 .. rowN</code> and 2 columns named <code>col0</code> and <code>col1</code>. If the regular
structure necessary to infer a table doesn't exist, then the subtree
will be visualized as a vector.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gui-builder"><a class="header" href="#gui-builder">GUI Builder</a></h1>
<p>The browser is not only for displaying tables, it is a custom gui
builder with it's own embedded scripting language and access to most
of the widgets in GTK. The design mode button opens the GUI builder
window, which allows you to display and modify an existing GUI as well
as build one from scratch.</p>
<p><img src="browser/./browser-gui-builder.png" alt="Design Mode" /></p>
<p>The GUI builder has two parts, starting from the top,</p>
<p>On top is the widget tree. Layout is automatic, and is based on the
structure of the widget tree, as such, you get the visual look you
want for your app by manipulating this tree as well as setting widget
properties. You can drag and drop nodes around, and using the buttons
just above the tree you can,</p>
<ul>
<li>create a sibling of the currently selected node</li>
<li>create a child of the currently selected node</li>
<li>delete the currently selected node as well as all of it's children</li>
<li>duplicate the currently selected node as well as all of it's children</li>
<li>undo</li>
</ul>
<p>Below the widget tree the properties of the currently selected widget
are shown. This includes all visual options, as well as event
handlers.</p>
<p>When the GUI builder window is open, the main browser window continues
to function normally. Any changes made in the design window are
reflected immediatly in the main window. The currently selected widget
in the widget tree is highlighted in blue in the main window.</p>
<p><img src="browser/./browser-design-mode.png" alt="Design Mode" /></p>
<p>When building GUIs using the browser, most of the interesting code
should live in the publisher. However some logic specific to the user
interface may be needed, and for this there is bscript, which will be
covered in the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-overview"><a class="header" href="#language-overview">Language Overview</a></h1>
<p>The browser scripting language exists to glue the widgets in your gui
to the inputs and outputs in netidx, and to compute your formulas in
the container. If you're familiar with the model view controller gui
paradigm, browser script is the controller layer. Because of it's
purpose it works differently from most scripting languages, in that it
is a 'reactive' or 'incremental' language. Instead of describing
"steps the computer performs when I click the button" like most other
languages, browser script describes where events go, and what
transformations happen to them.</p>
<p>For example the event handler for a button might look like so,</p>
<pre><code>store("[base]/app/do_action", event())
</code></pre>
<p>Store is a function that takes two event sources as arguments. The
first is expected to describe where in netidx to write, and the second
provides the values that are written.  We can think of this expression
as building an event pipeline that looks something like this,</p>
<pre><code>get(base) ------------1-&gt; concat_string ---------
                                ^                |
                                |                |
"/app/do_action" -------------2-                 1
                                                 v
event() -----------------------------------2-&gt; store
</code></pre>
<ul>
<li>When the user performs an action <code>event()</code> emits a <code>Null</code> which is
received by <code>store</code> and ultimately either written right away to the
path specified by store's first argument, or retained until store's
first argument is a valid path.</li>
<li>When the value of <code>base</code> is changed it's new value is emitted to
<code>concat_string</code>, which concatinates it with it's second argument (a
constant) and emits the result to store. Store will then either wait
for event to emit a value, or if event has already emitted a value
in the past then store will write that value to the new path it just
received.</li>
</ul>
<h1 id="compile-time-vs-run-time"><a class="header" href="#compile-time-vs-run-time">Compile Time vs Run Time</a></h1>
<p>When a view is first loaded all BScript expressions in it are compiled
into event graphs like the one visualized above. From then on, as the
view runs, events are generated and flow through the graphs, but no
additional compilation takes place.</p>
<p>The only exception to this rule is the <code>eval</code> function, which compiles
and executes new BScript code on the fly from a string.</p>
<p>Since all BScript expressions are compiled at view load time, if you
write an expression that just immediatly does something, then whatever
it does will happen when the view is loaded. That holds true no matter
where you put it, e.g. say we put the following as the <code>enabled</code>
expression of a toggle.</p>
<p><code>any(true, store("/foo/bar", 42))</code></p>
<p>Since <code>any</code> always returns the left most event it receives, it will
evaluate to true, making the toggle enabled, however every time the
view containing this expression is loaded <code>42</code> will also be stored at
<code>/foo/bar</code>.</p>
<p>It's important to understand these semantics if you want to write more
complex applications using BScript. The bscript widget is an invisible
widget specifically meant for setting up these "background" event
graphs. For example, we might want to have a variable called <code>base</code>
that contains the base relative to which our view will operate. We can
easily reference this variable in all our widgets, and the correct way
to set it's value would be to put it's initialization expression in a
bscript widget. e.g.</p>
<pre><code>base &lt;- load("/where")
</code></pre>
<h1 id="scope"><a class="header" href="#scope">Scope</a></h1>
<p>Bscipt variables are lexically scoped, both in terms of their lexical
position in code, and the position of the widget they attach to, or in
the case of the container their base path in netidx. Container widgets
such as Box, Grid, Paned, etc introduce new scopes, so bscripts that
are compiled in the context of these widgets may set local variables
that are not visible above them. Local variable bindings are made
using,</p>
<pre><code>let var &lt;- expr
</code></pre>
<p>This will bind a local variable <code>var</code> to <code>expr</code>in the current scope,
or will assign to an already bound local variable in the current
scope. If a variable of the same name exists in a parent scope, that
variable will be shadowed in the current scope and below, but it's
value will not be assigned, and it will remain unchanged in higher and
sibling scopes.</p>
<p>The bare assignment assigns to the variable in the closest scope with
a matching name, and if there is no such vaiable, then it binds a
global variable.</p>
<pre><code>var &lt;- expr
</code></pre>
<p>Either assigns to the local variable <code>var</code> in the current scope, or
any parent scope, if it exists, or it binds <code>var</code> to <code>expr</code> in the
global scope.</p>
<p>The do expr, <code>{ expr; expr; ... }</code>, introduces a new lexical scope
unless it is the toplevel do in a script expression. e.g.</p>
<pre><code>{
   let var &lt;- expr;
   ...
}
</code></pre>
<p><code>var</code> has the same scope as</p>
<pre><code>let var &lt;- expr
</code></pre>
<p>However,</p>
<pre><code>{
   ...;
   {
       let var &lt;- expr;
       ...
   }
   ...
}
</code></pre>
<p>In this case the inner do expr introduces a new lexical scope, so
<code>var</code> is only visible inside that scope and it's child scopes. You can
think of this as each toplevel script expr allowing multiple
statements at the top level. For code concision we are allowed to omit
the curly braces when we only have one statement</p>
<p>e.g. every toplevel bscript expression is implicitly,</p>
<pre><code>{ expr }
</code></pre>
<p>but we can just write</p>
<pre><code>expr
</code></pre>
<h1 id="types-and-constants"><a class="header" href="#types-and-constants">Types and Constants</a></h1>
<p>Types in browser script correspond to the netidx value type, and are
named,</p>
<ul>
<li>u32: unsigned 4 byte integer</li>
<li>v32: unsigned leb128 encoded integer</li>
<li>i32: signed 4 byte integer</li>
<li>z32: signed leb128 zig-zag encoded integer</li>
<li>u64: unsigned 8 byte integer</li>
<li>v64: unsigned leb128 encoded integer</li>
<li>i64: signed 8 byte integer</li>
<li>z64: signed leb128 zig-zag encoded integer</li>
<li>f32: single precision floating point number</li>
<li>f64: double precision floating point number</li>
<li>bool: boolean</li>
<li>string: unicode string</li>
<li>bytes: byte array</li>
<li>array: an array of values (including arrays)</li>
<li>result: ok or error:description of error</li>
</ul>
<p>Constants may be prefixed with the type name followed by a colon, e.g.</p>
<p><code>f32:3.14</code></p>
<p>However constant expressions have a default type if none is specified,</p>
<ul>
<li>floating point numbers: f64</li>
<li>integers: i64</li>
<li>strings: string</li>
<li>true/false: bool</li>
<li>ok: result</li>
</ul>
<p>e.g. <code>3.1415</code> is the same as <code>f64:3.1415</code>, and both forms will be
accepted.</p>
<p>Arrays may be specified with the syntax <code>[ expr, expr, ... ]</code>, where
expr is a regular bscript expression. In the case that any of the
expressions defining an array update, the entire array will be
regenerated with the new value substituting for the old one.</p>
<pre><code>[ load("/foo"), load("/bar") ]
</code></pre>
<p>Will generate a new pair whenever either foo or bar update.</p>
<h1 id="expression-interpolation"><a class="header" href="#expression-interpolation">Expression Interpolation</a></h1>
<p>In a string literal you may substitute any number of expressions by
surrounding them with <code>[]</code>. To produce a literal <code>[</code> or <code>]</code> you must
escape them with <code>\</code>, e.g. <code>\[</code> and <code>\]</code>. To produce a literal <code>\</code> you
may escape it as well, e.g. <code>\\</code>. Any expression is a valid
interpolation (including another interpolation). Non string valued
expressions will be cast to strings, and any expression that cannot be
cast to a string will be replaced with the empty string.</p>
<p>e.g.</p>
<pre><code>"[base]/some/path" =&gt; string_concat(get("base"), "/some/path")
</code></pre>
<pre><code>"[base]/bar/[if(load("[base]/enabled"),"enabled","disabled")]/thing" =&gt; 
string_concat(
    get("base"),
    "/bar/",
    if(
        load(string_concat(get("base"), "/enabled")),
        "enabled",
        "disabled"
    ),
    "/thing"
)
</code></pre>
<h1 id="the-expression-inspector"><a class="header" href="#the-expression-inspector">The Expression Inspector</a></h1>
<p>The expression inspector shows a tree representation of a BScript
expression in it's first column, and the current value of the
corresponding expression in it's second.</p>
<p><img src="browser/./expression-inspector.png" alt="Expression Inspector" /></p>
<p>In this case the expression being inspected is,</p>
<pre><code>base &lt;- "[archive_base]/[sessionid]/data"
</code></pre>
<p>You can access the expression inspector by pressing the toggle button
to the right of the expression box.</p>
<p><img src="browser/./bscript-code-box.png" alt="Code Box" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgets"><a class="header" href="#widgets">Widgets</a></h1>
<p>The browser supports several widgets. Most widgets also share common
properties, which are found under the common properties expander in
the lower half of the gui builder. The current supported common
properties are,</p>
<ul>
<li>Horizontal Alignment: Fill, Start, End, Center, or Baseline. Fill is the default.</li>
<li>Vertical Alignment: Fill, Start, End, Center, or Baseline. Fill is the default.</li>
<li>expand vertically</li>
<li>expand horizontally</li>
<li>top margin</li>
<li>bottom margin</li>
<li>start margin</li>
<li>end margin.</li>
</ul>
<p>These layout properties can be adjusted until you have the layout you
want in the main window. There are two additional properties, which
take bscript expressions instead of static values, these are</p>
<ul>
<li>sensitive: true if the user can interact with the widget, false otherwise</li>
<li>visible: true if the widget should be drawn, false otherwise.</li>
</ul>
<p>Since these are bscript expressions they can change at any time and
the gui will change.</p>
<p><img src="browser/./widget-common.png" alt="Common Properties" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frame"><a class="header" href="#frame">Frame</a></h1>
<p><img src="browser/./widget-frame.png" alt="Frame" /></p>
<p>The frame widget draws a frame around it's child widget, with an
optional label. It supports the following static layout parameters,</p>
<ul>
<li>label horizontal alignment: a floating point number between 0 and 1
that controls the horizontal placement of the label, with 0 being
the left and 1 being the right.</li>
<li>label vertical alignment: a floating point number between 0 and 1
that controls the label's placement relative to the upper line of
the frame box. 0 being fully below the line, and 1 being fully above
the line.</li>
</ul>
<p>Frame also supports the following bscript parameters,</p>
<ul>
<li>label: The text of the label. If this is not a string then no label
will be drawn.</li>
</ul>
<p><img src="browser/./editor-frame.png" alt="Frame Editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box"><a class="header" href="#box">Box</a></h1>
<p><img src="browser/./widget-box.png" alt="Box" /></p>
<p>The box widget arranges it's child widgets either vertically or
horizontally. Box is one of the basic primitives of layout in the
browser. It supports the following static parameters,</p>
<ul>
<li>direction: either vertical or horizontal.</li>
<li>homogeneous: if checked then the box will force all it's children to
be the same size.</li>
<li>spacing: how much empty space to include between each child widget.</li>
</ul>
<p>Boxes can be nested to achieve various layout effects.</p>
<p><img src="browser/./editor-box.png" alt="Box Editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grid"><a class="header" href="#grid">Grid</a></h1>
<p><img src="browser/./widget-grid.png" alt="Grid" /></p>
<p>The Grid widget allows you to layout widgets in a 2d grid. By default,
grid will make a row for each of it's children. However if the child
is a GridRow widget, then it's children will become
columns. Individual grid children may be configured with additional
parameters by placing them under GridChild widgets. This is a little
complex, but with it you can get a lot of control over your
layouts. The GridChild widget can tell the grid that a given widget
should be more than 1 columns wide, or more than 1 rows tall. GridRows
can be arranged to precisely define the rows and columns of the
widget, and you can see the layout change as you drag and drop widgets
around in the tree. The Grid widget supports the following static properties,</p>
<ul>
<li>homogeneous columns: If checked then all widgets in all columns are
forced to be the same width.</li>
<li>homogeneous rows: If checked then all widgets in all columns are
forced to be the same height.</li>
<li>column spacing: How much empty space to leave between each column</li>
<li>row spacing: How much empty space to leave between each row</li>
</ul>
<p>The GridChild widget supports the following static properties,</p>
<ul>
<li>width: The width, in columns, of this widget</li>
<li>height: The height, in rows, of this widget</li>
</ul>
<p>The GridRow widget is just a marker widget, it doesn't support any
properties.</p>
<p><img src="browser/./editor-grid.png" alt="Grid Editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paned"><a class="header" href="#paned">Paned</a></h1>
<p><img src="browser/./widget-paned.png" alt="Paned" /></p>
<p>The paned widget creates two user resizable sub regions of the
space. The division can be either vertical or horizontal. The Paned
widget supports the following properties,</p>
<ul>
<li>direction: either vertical or horizontal.</li>
<li>wide handle: if checked the handles will be wider than the default</li>
</ul>
<p><img src="browser/./editor-paned.png" alt="Paned Editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notebook"><a class="header" href="#notebook">Notebook</a></h1>
<p><img src="browser/./widget-notebook.png" alt="Notebook" /></p>
<p>The notebook widget allows you to create essentailly a tabbed set of
windows that the user can select, or that you can select with
bscript. It supports the following static properties,</p>
<ul>
<li>position: The position of the tabs, top, left, bottom, or right.</li>
<li>tabs visible: If this is not checked then the tabs won't be visible,
bscript will be the only way to switch tabs.</li>
<li>tabs scrollable: If you have too many tabs to fit on the screen
checking this will make them scrollable.</li>
<li>tabs have popup menu: If you have too many tabs to fit on the screen
checking this will make a popup menu so the user can still select
the tabs that don't fit.</li>
</ul>
<p>As well as static properties the notebook widget also has bscript
properties,</p>
<ul>
<li>page: the 0 indexed page that is currently selected in the
notebook. When this updates the notebook will change which page is
shown.</li>
<li>on switch page: event() will yield the 0 indexed page that the
notebook is currently displaying. That is, event() will update when
the page changes.</li>
</ul>
<p>The NotebookPage widget can be placed under the notebook in order to
configure properties of each page. It has the following static properties,</p>
<ul>
<li>tab label: the name of the page that is displayed to the user</li>
<li>reorderable: if checked then the user can reorder the pages by
dragging them.</li>
</ul>
<p><img src="browser/./editor-notebook.png" alt="Notebook Editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-1"><a class="header" href="#table-1">Table</a></h1>
<p><img src="browser/./widget-table.png" alt="Table" /></p>
<p>The table widget is used for displaying tabular data from netidx. It
is quite flexable, with many bscript properties, so it can be used for
many purposes. It supports direct editing, mediated by bscript, and it
can even display images, checkboxes, spin buttons, and combo boxes in
cells. It's properties are,</p>
<h2 id="path"><a class="header" href="#path">Path</a></h2>
<p>The path to the data to be displayed. This is bscript, so if it
updates to a new path then the table will redraw that new path.</p>
<h2 id="sort-mode"><a class="header" href="#sort-mode">Sort Mode</a></h2>
<p>This defines how sorting is done. Sorting can be done internally in
the browser, in which case the browser will subscribe to every value
in the column and will sort the values internally. It can also be done
on the publisher side, or disabled entirely. Sort mode has the form,</p>
<pre><code>
(null | false | external | &lt;column&gt; | spec)

external: [false, [spec, ...]]

spec: [&lt;column&gt;, ("ascending" | "descending")]
</code></pre>
<ul>
<li>
<p>null: The table is not sorted by default, but the user can sort by
clicking on column headers. Click events will also be generated when
the user clicks on the header button, see On Header Click.</p>
</li>
<li>
<p>false: sorting within the browser is disabled, but click events will
still be generated when the user clicks on the header buttons. These
events could be used to trigger publisher side sorting, or any other
desired action. See, On Header Click.</p>
</li>
<li>
<p>external: just like <code>false</code>, however sort indicators will be shown
as specified by the indicator spec. Use this if you implement
sorting in the publisher, but want to give the user feedback about
what is sorted. Example,</p>
<p><code>[false, [["artist", "descending"], ["album", "descending"]]]</code></p>
<p>Indicates that sorting is happening on the publisher side, and the
indicators should be show on the artist and album columns.</p>
</li>
<li>
<p><code>&lt;column&gt;</code>: by default sort by <code>&lt;column&gt;</code> in descending
order. Sorting is processed within the browser and is under the
user's control. Click events will also be generated when the user
clicks on the header button, see On Header Click. Example,</p>
<p><code>"artist"</code></p>
<p>sort by the artist column descending</p>
</li>
<li>
<p>spec: Same as column, except the sort direction is explicitly
specified. Example,</p>
<p><code>["artist", "ascending"]</code></p>
<p>sort by the artist column ascending</p>
</li>
</ul>
<h2 id="selection-mode"><a class="header" href="#selection-mode">Selection Mode</a></h2>
<p>This controls user selection it can be "single", "multi", or "none"</p>
<ul>
<li>"single": The user can only select 1 cell at a time</li>
<li>"multi": The user can select multiple cells by holding shift while
clicking or arrowing.</li>
<li>"none": The user can't select cells</li>
</ul>
<h2 id="column-filter"><a class="header" href="#column-filter">Column Filter</a></h2>
<p>The column filter allows you to remove columns from the table, and
also control their ordering. It has the form,</p>
<pre><code>
(null | true | false | list | range)

list: [list-mode, (&lt;col&gt; | [&lt;col&gt;, ...])]

range: [range-mode, [(&lt;n&gt; | "start"), (&lt;m&gt; | "end")]]

list-mode: ("include" | "exclude" | "include_match" | "exclude_match")

range-mode: ("keep" | "drop")
</code></pre>
<ul>
<li>null: all columns are included</li>
<li>true: all columns are included</li>
<li>false: no columns are included</li>
<li>list: Specify a list of columns or column regexes to include or
exclude.
<ul>
<li>"include": col/cols is a list of columns to show. The order of
the columns in the list controls the order of the columns that
are displayed.</li>
<li>"exclude": col/cols is a list of columns to hide</li>
<li>"include_match": col/cols is a list of regex patterns of columns
to show</li>
<li>"exclude_match": col/cols is a list of regex patterns of columns
to hide</li>
</ul>
</li>
<li>range: Specify columns to keep or drop by numeric ranges. Range
patterns apply to the positions of columns in the sorted set.
<ul>
<li>"keep": keep the columns specified by the range, drop any
others. If the range specifies more columns than exist all
columns will be kept. Matched items will be &gt;= start and &lt; end.</li>
<li>"drop": drop the columns specified by the range, keeping the
rest. If the range specifies more columns than exist all the
columns will be dropped. Matched items will be &lt; start or &gt;=
end.</li>
</ul>
</li>
</ul>
<p>Examples,</p>
<p><code>["include", ["col0", "col1", "col2"]]</code></p>
<p>include only col0, col1, and col2 in that order</p>
<p><code>["exclude", ["col0"]]</code></p>
<p>include every column except col0.</p>
<p><code>["include_match", "\[0-9\]+$"]</code></p>
<p>include all columns that end in a number</p>
<p><code>["drop", [10, "end"]]</code></p>
<p>drop all columns after column 9.</p>
<p>It is important to note that only "include" allows you to control the
column order, in all other cases the columns will be sorted
lexicographically.</p>
<h2 id="column-editable"><a class="header" href="#column-editable">Column Editable</a></h2>
<p>This field has the same format as the column filter, but instead of
controling visiblity it controls whether the column can be directly
edited (the user can always try ctrl+w to write).</p>
<p>The actual editing is not direct, but must be handled by the On Edit
bscript event handler. So this filter is really determining which
columns can trigger that event handler.</p>
<h2 id="column-widths"><a class="header" href="#column-widths">Column Widths</a></h2>
<p>This expression allows you to control the default widths of columns.</p>
<pre><code>
(null | widths)

widths: [[&lt;name&gt;, &lt;w&gt;], ...]
</code></pre>
<ul>
<li>null: initial column widths are automatically determined</li>
<li>widths: The list of numeric values specify the initial width of the
corresponding column.</li>
</ul>
<p>Example,</p>
<p><code>[["col0", 300], ["col1", 200], ["col2", 50]]</code></p>
<h2 id="columns-resizable"><a class="header" href="#columns-resizable">Columns Resizable</a></h2>
<p>if true then the user can resize columns, if false they cannot.</p>
<h2 id="column-types"><a class="header" href="#column-types">Column Types</a></h2>
<p>Column types allows you to use columns that are not text as well as
configure additional properties of text columns such as background and
foreground colors. You don't have to mention every column in the
column types expression. Any columns you don't mention will be plain
text columns.</p>
<pre><code>
(null | column_types)

null: a default column type specification is generated that
displays all the columns in the filtered model as text.

column_types: [[&lt;name&gt;, typename, properties], ...]

typename: ("text" | "toggle" | "image" | "combo" | "spin" | "progress" | "hidden")

common: common properties shared by many columns
  ["source", &lt;column-name&gt;],
    optional, the source column that contains the data for
    each row. If not specified the default is this column
    (&lt;name&gt;).

  ["background", &lt;color-string&gt;],
    optional, statically specify the background color of the
    cell. same format as the "foreground" attribute.

  ["background-column", &lt;column-name&gt;],
    optional, the column containing the background color of
    each row in the same format as described in the
    "foreground" attribute.


properties: match typename
  "text": [
    common,

    ["foreground", &lt;color-string&gt;],
      optional, statically specify the foreground text
      color. Any string understood by pango_parse_color is
      understood here. That includes css color names, and hex
      strings in various formats.

    ["foreground-column", &lt;column-name&gt;],
      optional, the column containing the foreground color of
      each row, same format as for the "foreground" attribute.
  ]
  
  "toggle": [
    common,

    ["radio", (true | false)],
      optional, whether to render the toggle as a check button
      or a radio button.

      true: the entire column is radio buttons, only one row may
      be selected at any one time

      false: the entire column is check buttons, which may be
      individually toggled.

      &lt;column-name&gt;: the specified boolean column controls
      whether or not the toggle in each row is a radio or a
      check button.

    ["radio-column", &lt;column-name&gt;]
      optional, the column containing the "radio" property for
      each row
  ]

  "image": [
    common,
  ]

  "combo": [
    common,

    ["choices", [&lt;choice&gt;, ...]],
      The available choices globally for the entire
      column. One of choices or choices-column must be
      specified

    ["choices-column", &lt;column-name&gt;]
      The column containing the "choices" attribute
      for each row. One of choices, or choices-column must be
      specified.

    ["has-entry", (true | false)],
      optional. Should the column have an entry in addition to
      the combo box menu? If true the user will be able to
      enter any text they want, even if it isn't a valid
      choice. If false only valid choices may be entered.

    ["has-entry-column", &lt;column-name&gt;]
      optional, the column containing the has-entry attribute for each row.
  ]

  "spin": [
     common,

     ["min", &lt;n&gt;],
       optional, if not specified 0 is assumed.

     ["min-column", &lt;column-name&gt;]
       optional, the column containing the min attribute for each row

     ["max", &lt;n&gt;],
       optional, if not specified 1 is assumed.

     ["max-column", &lt;column-name&gt;]
       optonal, the column containing the max attribute for each row

     ["increment", &lt;n&gt;],
       optional, the amount the value changes with each spin button press

     ["increment-column", &lt;column-name&gt;],
       optional, the column containg the increment property

     ["page-increment", &lt;n&gt;]
       optional, the amount the value changes on a page increment

     ["page-increment-column", &lt;column-name&gt;],
       optional, the column containg the page-increment property

     ["climb-rate", &lt;n&gt;],
       optional. How fast the value should change if the user
       holds the + or - button down.

     ["climb-rate-column", &lt;column-name&gt;]
       optional, the column specifying the climb-rate attribute for each row

     ["digits", &lt;n&gt;],
       optional. The number of decimal places to display.

     ["digits-column", &lt;column-name&gt;]
       optional. The column specifying the digits attribute for each row.
  ]

  "progress": [
    common,
      
    ["activity-mode", (true | false)],
      optional, default false. Operate the progressbar in
      activity mode (see the ProgressBar widget).

    ["activity-mode-column", &lt;column-name&gt;]
      optional, the column specifying the activity mode for each row.

    ["text", &lt;text&gt;],
      optional, display static text near the progress bar

    ["text-column", &lt;column-name&gt;],
      optional, display text from &lt;column-name&gt; near the
      progress bar.

    ["text-xalign", &lt;n&gt;],
      optional, set the horizontal alignment of the displayed
      text. 0 is full left, 1 is full right.

    ["text-xalign-column", &lt;column-name&gt;]
      optional, the column specifying the text-xalign property for each row

    ["text-yalign", &lt;n&gt;],
      optional, set the vertical alignment of the displayed
      text. 0 is top, 1 is bottom.

    ["text-yalign-column", &lt;column-name&gt;]
      optonal, the column specifying the text-yalign property for each row

    ["inverted", (true | false)],
      optional, invert the meaning of the source data

    ["inverted-column", &lt;column-name&gt;]
      optional, the column specifying the inverted property for each row
 ]

 "hidden":
   hidden is a special column type that has no properties. It
   is used to hide data columns that other visible columns
   depend on (so they must appear in the model), but that you
   don't want to show to the user.
</code></pre>
<p>all the properties of progress are optional. If none are set
the entire properties array may be omitted</p>
<p>The column type specification interacts with the column filter, in
that a column type specification may name another column as the source
of it's data or of a given property and the column filter may remove
that column. If that occurrs the column filter takes precidence. The
specified typed column will be displayed, but won't get any data if
it's underlying column is filtered out.</p>
<p>For properties that can be statically specified and loaded from a
column, if both ways are specified then the column will override the
static specification. If the column data is missing or invalid for a
given row, then the static specification will be used. e.g. if I
specify both <code>["text-yalign", 1]</code> and <code>["text-yalign-column", "foo"]</code>,
then 1 will be used if the data from foo is missing, otherwise foo
will be used.</p>
<p>Examples,</p>
<pre><code>
[
  ["images", "image", [["source", "000"]]],
  ["checkboxes", "toggle", [["source", "001"]]],
  ["combos", "combo", [["source", "002"], ["choices-column", "003"]]],
  ["004", "hidden", []],
  ["005", "hidden", []]
]
</code></pre>
<p><img src="browser/./widget-table-advanced.png" alt="Advanced" /></p>
<p>In this example we start with a container sheet, and we construct a
table with columns that don't exist in the underlying data (images,
checkboxes, and combos). These columns reference data in the
underlying table via the <code>source</code> attribute, and in the combos column
the choices also come from an underlying column.</p>
<p>Meanwhile we hide some of the underying columns. In a real application
we might use these features to create a view of a dataset that is very
different from what the underying table looks like "raw".</p>
<h2 id="row-filter"><a class="header" href="#row-filter">Row filter</a></h2>
<p>The row filter has the same format as the column filter, except it
operates on the rows of the table.</p>
<h2 id="show-row-name"><a class="header" href="#show-row-name">Show Row Name</a></h2>
<p>By default the first column in the table is the name of the row. If
this field is false then the row name will not be shown.</p>
<h2 id="on-activate"><a class="header" href="#on-activate">On Activate</a></h2>
<p>This event is triggered when the user double clicks a row or presses
enter in a row. The <code>event()</code> function will yield <code>null</code> when that
happens.</p>
<h2 id="on-select"><a class="header" href="#on-select">On Select</a></h2>
<p>This event is triggered when the user selects one or more cells in the
table. <code>event()</code> will yield the new selection as a list of paths.</p>
<h2 id="on-edit"><a class="header" href="#on-edit">On Edit</a></h2>
<p>This event is triggered when the user edit a cell in an editable
column. <code>event()</code> will yield a pair of the path of the edited cell and
the new value.</p>
<h2 id="on-header-click"><a class="header" href="#on-header-click">On Header Click</a></h2>
<p>This event is triggered when the user clicks on a column
header. <code>event()</code> will yield the name of the column who's header was
clicked.</p>
<h2 id="the-full-table-editor"><a class="header" href="#the-full-table-editor">The Full Table Editor</a></h2>
<p><img src="browser/./editor-table.png" alt="table editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image"><a class="header" href="#image">Image</a></h1>
<p><img src="browser/./widget-image.png" alt="Image" /></p>
<p>The image widget allows displaying an image in the browser. The image
has two bscript properties.</p>
<h2 id="spec"><a class="header" href="#spec">spec</a></h2>
<pre><code>
(&lt;icon-name&gt; | icon-spec | &lt;image-bytes&gt; | image-spec)

icon-spec: [&lt;icon-name&gt;, icon-size]

icon-size: ("menu" | "small-toolbar" | "large-toolbar" | "dnd" | "dialog")

image-spec: [
   ["image", &lt;image-bytes&gt;],
     required, the image bytes.

   ["width", &lt;desired-width&gt;],
     optional, if specified the image will be scaled to the
     specified width. If keep-aspect is true then the height
     will also be scaled to keep the image's aspect ratio even
     if height is not specified.

   ["height", &lt;desired-height&gt;],
     optional, if specifed the image will be scaled to the
     specified height. If keep-aspect is true then the width
     will also be scaled to keep the image's aspect ratio even
     if width is not specified.

   ["keep-aspect", (true | false)]
     optional, keep the aspect ratio of the image.
]
</code></pre>
<ul>
<li><icon-name>: A string naming the stock icon from the current theme
that should be displayed. The default size is "small-toolbar".</li>
<li>icon-spec: A pair specifying the icon name and the icon size.</li>
<li>icon-size: The size of the icon</li>
<li><code>&lt;image-bytes&gt;</code>: A bytes value containing the image in any format
supported by gdk_pixbuf.</li>
<li>image-spec: an alist containing the image bytes in any format
supported by gdk_pixbuf and some metadata.</li>
</ul>
<p>Examples,</p>
<p><code>"media-floppy-symbolic"</code></p>
<p>Display the icon from the standard icon set.</p>
<p><code>&lt;binary-png-data&gt;</code></p>
<p>Display the png data, literally the raw bytes copied into netidx
directly from the file.</p>
<h2 id="on-click"><a class="header" href="#on-click">On Click</a></h2>
<p>This event handler is triggered when the user clicks on the
image. <code>event()</code> will yield <code>null</code> when that happens.</p>
<p><img src="browser/./editor-image.png" alt="image editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="label"><a class="header" href="#label">Label</a></h1>
<p><img src="browser/./widget-label.png" alt="the humble label" /></p>
<p>The label widget displays a text label. It has the following bscript
properties,</p>
<ul>
<li>Text: the contents of the label. If the value is not a string it
will be converted to one.</li>
<li>Min Width: The minimum desired width in characters. The widget will
force the window to be at least this wide.</li>
<li>Ellipsize Mode: one of "none", "start", "middle", or "end". This
property defines what happens if the text is too large to fit in the
widget.
<ul>
<li>"none": the window will be forced to grow until the text fits</li>
<li>"start": the text will be truncated and replaced with ... at the
start.</li>
<li>"middle": the text will be truncated and replaced with ... in the
middle.</li>
<li>"end": the text will be truncated and replaced with ... at the
end.</li>
</ul>
</li>
<li>Single Line: if true then the label is restricted to a single line,
newlines in the text are ignored. Otherwise it can span multiple
lines.</li>
<li>Selectable: if true then the text in the label is selectable, if
false it is not.</li>
</ul>
<p><img src="browser/./editor-label.png" alt="label editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="button"><a class="header" href="#button">Button</a></h1>
<p><img src="browser/./widget-button.png" alt="The humble button" /></p>
<p>The button widget draws a clickable button. It has 3 bscript
properties,</p>
<ul>
<li>Label: The text to be drawn in the button.</li>
<li>Image: The image to be drawn in the button. This field uses the same
format as the image widget's spec property. The image will be drawn
in addition to the text label, so if you want just an image leave
the text blank.</li>
<li>On Click: The <code>event()</code> function in this property will yield <code>null</code>
when the user clicks the button.</li>
</ul>
<p><img src="browser/./editor-button.png" alt="button editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="link-button"><a class="header" href="#link-button">Link Button</a></h1>
<p><img src="browser/./widget-link-button.png" alt="Link Button" /></p>
<p>The link button draws a clickable hypertext link. It has 3 bscript
properties,</p>
<ul>
<li>
<p>Label: the text of the link</p>
</li>
<li>
<p>URI: The URI of the link.</p>
</li>
<li>
<p>On Activate Link: This event handler will be triggered when the link
is clicked. The <code>event()</code> function will yield the uri. If the
handler expression yields <code>true</code>, then the uri will be considered
handled and no further action will happen. If the handler expression
doesn't yield <code>true</code>, then the uri will be handled by the system.</p>
<p>An https uri should open the requested page in the default browser,
a file uri should open the specified location in the file
manager. etc. Any uri the system knows how to handle should work.</p>
<p>Example</p>
<pre><code>any(
  confirm("navigate to: ", event()), 
  sample(event(), true)
)
</code></pre>
<p>Ask the user if they want to navigate to the uri. If they say no,
confirm won't update, and sample will update with true, so any will
update with true, and the click event will be marked as fully
handled. If they say yes, then confirm will update with the uri any
will update with the uri, which isn't true, so the system handler
will be invoked.</p>
</li>
</ul>
<p><img src="browser/./editor-link-button.png" alt="Link Button Editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="switch"><a class="header" href="#switch">Switch</a></h1>
<p><img src="browser/./widget-switch.png" alt="Switch" /></p>
<p>Switch draws a physically inspired switch. The user can toggle the
switch by clicking it, however it's state is controlled by bscript. It
has two bscript properties,</p>
<ul>
<li>Value: The value of the switch. If this is any value except <code>false</code>
or <code>null</code> then the switch is on. If it is <code>false</code> or <code>null</code> then the
switch is off.</li>
<li>On Change: <code>event()</code> in this expression will yield the new requested
state of the switch as a bool. <code>false</code> for off <code>true</code> for on. This
handler has no direct effect on the state of the switch, instead the
value should be stored such that the Value expression updates with
the new state.</li>
</ul>
<p><img src="browser/./editor-switch.png" alt="Switch Editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="toggle-button"><a class="header" href="#toggle-button">Toggle Button</a></h1>
<p><img src="browser/./widget-toggle-button.png" alt="Toggle Button" /></p>
<p>Toggle button is like a switch, it can be pushed in or out. It's state
is controlled by bscript. It has 4 bscript properties,</p>
<ul>
<li>Value: Whether the button is in or out. If <code>true</code> the button is in,
if <code>false</code> the button is out.</li>
<li>On Change: <code>event()</code> will yield the new requested state of the
button. <code>true</code> for in, <code>false</code> for out.</li>
<li>Label: The text displayed in the button</li>
<li>Image: The image displayed in the button. This uses the same format
as the image widget's spec property. If both text and image are
valid then the button will have both an image and text.</li>
</ul>
<p><img src="browser/./editor-toggle-button.png" alt="Toggle Editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="combo-box"><a class="header" href="#combo-box">Combo Box</a></h1>
<p><img src="browser/./widget-combobox.png" alt="Combo Box" /></p>
<p>The combo box widget allows the user to pick from a list of values. It
has 3 bscript properties,</p>
<ul>
<li>
<p>Choices: The list of allowed choices. This is a list of pairs. The
first element of each pair is the string that will be sent by the
<code>event()</code> function when the user selects the choice, and the second
is the text that will be shown to the user.</p>
<p>Example</p>
<p><code>[["1", "One"], ["2", "Two"]]</code></p>
<p>The combo box will have allowed choices "One" and "Two".</p>
</li>
<li>
<p>Selected: This expression should resolve to one of the allowed
choices. It controls what is displayed as selected in the combo
box. Even if the user makes a different selection, if this property
doesn't update the selected item won't change.</p>
</li>
<li>
<p>On Change: <code>event()</code> in this expression will yield the key of the
item the user has selected. The handler should arrange to update the
selected property to reflect the user's change.</p>
</li>
</ul>
<p><img src="browser/./editor-combobox.png" alt="Combo editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="radio-button"><a class="header" href="#radio-button">Radio Button</a></h1>
<p><img src="browser/./widget-radio-button.png" alt="Radio Button" /></p>
<p>Radio buttons allow the user to select from a set of options. Radio
buttons only work when there are two or more, as they are are grouped
together, and within each group only one radio button may be active at
a time. There are 5 bscript properties,</p>
<ul>
<li>Label: The text shown to the right of the radio button.</li>
<li>Image: The image shown to the right of the radio button. This uses
the same format as the image widget's spec property. If both image
and text are present then both will be shown.</li>
<li>Group: The name of the group this radio button belongs to. Only one
button in each group may be active at any one time. If the user
selects a new button in a group then current active button will
toggle off and the new one will toggle on.</li>
<li>Value: The value of the radio button, <code>true</code> the radio button is
selected, <code>false</code> the radio button is not selected. If your
expressions produce an inconsistent state for a given group, then
the browser will pick one of the group members that is true to be
the one button that is selected. If your expression doesn't update
when the user selects an option, then the user's selection will
override your value.</li>
<li>On Toggled: <code>event()</code> called from this expression will yield <code>true</code>
or <code>false</code> when the radio button toggles.</li>
</ul>
<p><img src="browser/./editor-radio-button.png" alt="Editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entry"><a class="header" href="#entry">Entry</a></h1>
<p><img src="browser/./widget-entry.png" alt="Entry" /></p>
<p>Entry allows simple text entry. It has 3 bscript properties,</p>
<ul>
<li>Text: The text in the entry. This will be synced with the entry when
it updates, or when the user activates the entry by pressing enter.</li>
<li>On Change: <code>event()</code> in this expression will yield the text of the
entry every time the user changes it.</li>
<li>On Activate: <code>event()</code> in this expression will yield the text of the
entry when the user presses enter.</li>
</ul>
<p><img src="browser/./editor-entry.png" alt="Entry Editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="search-entry"><a class="header" href="#search-entry">Search Entry</a></h1>
<p><img src="browser/./widget-search-entry.png" alt="Search Entry" /></p>
<p>Search entry is very similar to entry, with two differences. It has
iconography indicating what it does and a convenient button to clear
it in one click, and it imparts a slight delay before calling On
Search Changed. Like entry it has three bscript properties,</p>
<ul>
<li>Text: as with entry this is the text in the search entry. It is
synced whenever it updates, or when the user activates the search
entry by pressing enter.</li>
<li>On Search Changed: <code>event()</code> in this expression will yield the text
of the entry when it changes, but after a slight delay.</li>
<li>On Activate: <code>event()</code> in this expression will yield the text of the
entry when the user activates the entry by pressing enter.</li>
</ul>
<p><img src="browser/./editor-search-entry.png" alt="Entry Editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scale-1"><a class="header" href="#scale-1">Scale</a></h1>
<p><img src="browser/./widget-scale.png" alt="Scale" /></p>
<p>Scale visualizes a floating point number between a minimum and maximum
value, and allows the user to drag the slider to change the value. It
has several properties,</p>
<h2 id="direction"><a class="header" href="#direction">Direction</a></h2>
<p>This static property indicates whether the slider is horizontal or
vertical.</p>
<h2 id="draw-value"><a class="header" href="#draw-value">Draw Value</a></h2>
<p>if <code>true</code> then the actual value is drawn, if <code>false</code> it is not.</p>
<h2 id="marks"><a class="header" href="#marks">Marks</a></h2>
<p>Allows displaying marks along the scale's axis. When dragging the
slider the browser will snap to the nearest mark, making these values
easy to hit exactly.</p>
<pre><code>[mark, ...]

mark: [&lt;pos&gt;, position-spec, (null | &lt;text&gt;)]

position-spec: ("left" | "right" | "top" | "bottom")
</code></pre>
<p>Example</p>
<pre><code>[
  [0.25, "bottom", "0.25"], 
  [0.5, "bottom", "0.5"], 
  [0.75, "bottom", "0.75"]
]
</code></pre>
<p>Will draw marks at 1/4, 1/2, and 3/4 along the axis on the bottom
side.</p>
<h2 id="has-origin"><a class="header" href="#has-origin">Has Origin</a></h2>
<p>If this propery is <code>true</code> then the left or top of the scale is
considered the origin, and the part from there to the handle will be
filled in.</p>
<h2 id="value"><a class="header" href="#value">Value</a></h2>
<p>This defines the position of the handle. It must be between the
minimum and maximum values.</p>
<h2 id="min"><a class="header" href="#min">Min</a></h2>
<p>The minimum value, this defines the origin if Has Origin is true.</p>
<h2 id="max"><a class="header" href="#max">Max</a></h2>
<p>The maximum value.</p>
<h2 id="on-change"><a class="header" href="#on-change">On Change</a></h2>
<p><code>event()</code> in this expression will yield the value of the slider
whenever the user changes it.</p>
<p><img src="browser/./editor-scale.png" alt="Editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="progress-bar"><a class="header" href="#progress-bar">Progress Bar</a></h1>
<p><img src="browser/./widget-progressbar.png" alt="Progress Bar" /></p>
<p>Progress bar displays the progress of some task that takes long enough
that you need to keep the user informed about it lest they get bored,
or think the application is stuck. It has several properties,</p>
<ul>
<li>Ellipsize: If the text is too large for the window it will be
ellipsized according to this property. Possible values are, "none",
"start", "middle", "end", which specify where the text will be
truncated and replaced with ...</li>
<li>Fraction: How far along the task is, expressed as a float between 0
and 1.</li>
<li>Pulse: If you don't know how long a task will take, but you still
want to tell the user "stuff is happening", then you can set pulse
to an expression that updates periodically. Each update will cause
the progress bar to move. You can mix pulse and fraction, e.g. you
can pulse for a while, and then set fraction, and then pulse for a
while.</li>
<li>Text: The text you wish to display above the progress bar,
e.g. could describe what it's doing now.</li>
<li>Show Text: <code>true</code> if you want to draw the text, <code>false</code> otherwise.</li>
</ul>
<p><img src="browser/./editor-progressbar.png" alt="Progress Bar Editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="line-plot"><a class="header" href="#line-plot">Line Plot</a></h1>
<p><img src="browser/./widget-lineplot.png" alt="Line Plot" /></p>
<p>The lineplot widget draws animated line plots with multiple series on
a plot and numerous configuration options.</p>
<h2 id="chart-style"><a class="header" href="#chart-style">Chart Style</a></h2>
<ul>
<li>Title: The title of the plot, shown on the top center.</li>
<li>Fill: The background fill color, if any. If the box is unchecked
then there will be no fill color</li>
<li>Margin: The size of the chart margins</li>
<li>Label Area: The size of the are reserved for the axis labels</li>
</ul>
<h2 id="axis-style"><a class="header" href="#axis-style">Axis Style</a></h2>
<ul>
<li>X Axis Label: The label of the X axis</li>
<li>Y Axis Label: The label of the Y axis</li>
<li>X Labels: The maximum number of points on the X axis that get
labeled</li>
<li>Y Labels: The maximum number of points on the Y axis that get
labeled</li>
<li>X Axis Grid: Draw grid lines along the X axis</li>
<li>Y Axis Grid: Draw grid lines along the Y axis</li>
</ul>
<h2 id="axis-range"><a class="header" href="#axis-range">Axis Range</a></h2>
<ul>
<li>x min: The minimum value on the X axis. If <code>null</code> this will be computed from the data set.</li>
<li>x max: The maximum value on the X axis. If <code>null</code> this will be computed from the data set.</li>
<li>y min: the minimum value on the Y axis. If <code>null</code> this will be computed from the data set.</li>
<li>y max: the maximum value on the Y axis. If <code>null</code> this will be computed from the data set.</li>
<li>keep points: The number of points of history to keep.</li>
</ul>
<h2 id="series"><a class="header" href="#series">Series</a></h2>
<p>There can be multiple series on a line plot, use the + and - buttons
to add/remove series from a plot.</p>
<ul>
<li>Title: The title of the series</li>
<li>Line Color: The color of the line associated with the series</li>
<li>X: The expression that generates the X coordinate of the series</li>
<li>Y: The expression that generates the Y coordinate of the series</li>
</ul>
<p>Example</p>
<p><code>X: { let tick &lt;- count(timer(f64:0.5, 1024)); tick }</code></p>
<p><code>Y: product(tick, tick)</code></p>
<p>This will animate the plot of <code>y = x ^ 2</code> 2 points per second out to
<code>x = 1024</code>.</p>
<p><img src="browser/./editor-lineplot.png" alt="Editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-clean-slate-design-using-netidx"><a class="header" href="#a-clean-slate-design-using-netidx">A Clean Slate Design Using Netidx</a></h1>
<p>In the last example we added netidx publishing of one data point, and
then explored what we could do with the data. In this example we're
going to look at a system designed from scratch to use netidx as it's
primary means of communication and control.</p>
<p>The system we're going to look at is the control program of an off the
grid solar generator. The system uses a Prostar MPPT controller, which
has a serial port over which it talks modbus. Connected to this port
is raspberry pi 3, called "solar", which is connected to wifi and
joined to samba ADS.</p>
<p>The control program is a simple translation layer between the modbus
interface of the Prostar and netidx. Full source code
<a href="https://github.com/estokes/solar">here</a>.</p>
<p>The main loop takes commands from either the local command socket, or
the netidx publisher, and sends them via modbus to the charge
controller, e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    loop {
        ...
        match msg {
            ToMainLoop::FromClient(msg, mut reply) =&gt; match msg {
                FromClient::SetCharging(b) =&gt; {
                    send_reply(mb.write_coil(ps::Coil::ChargeDisconnect, !b).await, reply)
                        .await
                }
                FromClient::SetLoad(b) =&gt; {
                    send_reply(mb.write_coil(ps::Coil::LoadDisconnect, !b).await, reply)
                        .await
                }
                FromClient::ResetController =&gt; {
                    send_reply(mb.write_coil(ps::Coil::ResetControl, true).await, reply)
                        .await
                }
                ...
<span class="boring">}</span></code></pre></pre>
<p>A message is either a timer Tick, on which we send out (and log)
updated stats, or an actual command, which we handle individually. The
publisher module is fed a new stats record read from modbus on each
timer tick. e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn update(&amp;self, st: &amp;Stats) {
        use chrono::prelude::*;
        self.timestamp
            .update_changed(Value::DateTime(DateTime::&lt;Utc&gt;::from(st.timestamp)));
        self.software_version.update_changed(Value::V32(st.software_version as u32));
        self.battery_voltage_settings_multiplier
            .update(Value::V32(st.battery_voltage_settings_multiplier as u32));
        self.supply_3v3.update_changed(Value::F32(st.supply_3v3.get::&lt;volt&gt;()));
        self.supply_12v.update_changed(Value::F32(st.supply_12v.get::&lt;volt&gt;()));
        self.supply_5v.update_changed(Value::F32(st.supply_5v.get::&lt;volt&gt;()));
        self.gate_drive_voltage
            .update_changed(Value::F32(st.gate_drive_voltage.get::&lt;volt&gt;()));
        self.battery_terminal_voltage
            .update_changed(Value::F32(st.battery_terminal_voltage.get::&lt;volt&gt;()));
    ...
<span class="boring">}</span></code></pre></pre>
<p>These are all published under <code>/solar/stats</code>, there are a lot of them,
so I won't show them all here, you can read the full source if you're
curious. Essentially it's an infinite loop of read stats from modbus,
update netidx, flush netidx, loop.</p>
<h2 id="what-about-control"><a class="header" href="#what-about-control">What About Control</a></h2>
<p>The above handles distributing the stats perfectly well, but for
control we need some way to send commands from the subscriber back to
the publisher, and that's where writes come in. If you've read the api
documentation you might have noticed,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn write(&amp;self, v: Value)
<span class="boring">}</span></code></pre></pre>
<p>Continuing with the metaphor of exporting variables to a cross machine
global namespace, it fits perfectly well to imagine that we can write
to those variables as well as read from them, publisher willing.</p>
<p>Our program is going to publish three values for control,
<code>/solar/control/charging</code> (to control whether we are charging the
batteries), <code>/solar/control/load</code> (to control whether the inverter is on
or off), and <code>/solar/control/reset</code> (to trigger a controller
reset). These values will all be boolean, and they will be valid for
both read and write. Here is the full code of the control section,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PublishedControl {
    charging: Val,
    load: Val,
    reset: Val,
}

impl PublishedControl {
    fn new(publisher: &amp;Publisher, base: &amp;Path) -&gt; Result&lt;Self&gt; {
        Ok(PublishedControl {
            charging: publisher.publish(base.append("charging"), Value::Null)?,
            load: publisher.publish(base.append("load"), Value::Null)?,
            reset: publisher.publish(base.append("reset"), Value::Null)?,
        })
    }

    fn update(&amp;self, st: &amp;Stats) {
        self.charging.update_changed(match st.charge_state {
            ChargeState::Disconnect | ChargeState::Fault =&gt; Value::False,
            ChargeState::UnknownState(_)
            | ChargeState::Absorption
            | ChargeState::BulkMPPT
            | ChargeState::Equalize
            | ChargeState::Fixed
            | ChargeState::Float
            | ChargeState::Night
            | ChargeState::NightCheck
            | ChargeState::Start
            | ChargeState::Slave =&gt; Value::True,
        });
        self.load.update_changed(match st.load_state {
            LoadState::Disconnect | LoadState::Fault | LoadState::LVD =&gt; Value::False,
            LoadState::LVDWarning
            | LoadState::Normal
            | LoadState::NormalOff
            | LoadState::NotUsed
            | LoadState::Override
            | LoadState::Start
            | LoadState::Unknown(_) =&gt; Value::True,
        });
    }

    fn register_writable(&amp;self, channel: fmpsc::Sender&lt;Pooled&lt;Vec&lt;WriteRequest&gt;&gt;&gt;) {
        self.charging.writes(channel.clone());
        self.load.writes(channel.clone());
        self.reset.writes(channel.clone());
    }

    fn process_writes(&amp;self, mut batch: Pooled&lt;Vec&lt;WriteRequest&gt;&gt;) -&gt; Vec&lt;FromClient&gt; {
        batch
            .drain(..)
            .filter_map(|r| {
                if r.id == self.charging.id() {
                    Some(FromClient::SetCharging(bool!(r)))
                } else if r.id == self.load.id() {
                    Some(FromClient::SetLoad(bool!(r)))
                } else if r.id == self.reset.id() {
                    Some(FromClient::ResetController)
                } else {
                    let m = format!("control id {:?} not recognized", r.id);
                    warn!("{}", &amp;m);
                    if let Some(reply) = r.send_result {
                        reply.send(Value::Error(Chars::from(m)));
                    }
                    None
                }
            })
            .collect()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In process_writes we translate each WriteRequest that is targeted at
one of the published controls into a FromClient message that the main
loop will act on. So from the main loop's perspective it doesn't
matter if a command came from netidx or the local control socket.</p>
<p>Note that it isn't necessary to do any authorization here, the
publisher library has already checked that the resolver server granted
the user making these writes permission to do them, and of course we
can control who is authorized to write in the resolver server
permissions.</p>
<p>For the basic day to day use case, that's all we need on the server
side. The entire daemon uses 6.5 MB of ram, and almost no cpu, it
could certainly run on a smaller device, though we depend on tokio,
which means we at least need a unix like OS under us.</p>
<p>The kerberos configuration for this service is also quite simple,
there is a service principal called svc_solar in samba ADS, and solar
has a keytab installed for it, as well as a cron job that renews it's
TGT every couple of hours.</p>
<h2 id="building-a-custom-gui-with-views"><a class="header" href="#building-a-custom-gui-with-views">Building a Custom GUI With Views</a></h2>
<p>What we have is fine as far as it goes, we can view our stats in the
browser, and we can write to the controls using the command line
subscriber. It's fine for scripting, but I'd also like a gui. e.g.</p>
<p><img src="examples/solar-gui.png" alt="Solar GUI" /></p>
<p>This can be built using design mode in the browser, the view can then
be saved to a file or written directly to a netidx path.</p>
<p><img src="examples/browser-design-mode.png" alt="Browser Design Mode" /></p>
<p>See the GUI Builder chapter for more information.</p>
<h2 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping Up</a></h2>
<p>In this example we saw how an application can be designed more or less
from the start to communicate with the outside world using netidx. We
didn't cover the opportunities for scripting our solar installation
now that we can control it using netidx, but we certainly could do any
of the nice things we did in the last chapter. We did show an example
gui, and I want to point out that having a gui in no way alters our
ability to script and manipulate the system programatically. It's
important to recognize that building a bespoke system with a gui as
complex as the one we built AND making it scriptable over the network
in a discoverable, secure, and performant way is not an easy task.
Usually it just isn't worth doing, however by using netidx it was
easy, and that's really the point of the whole thing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="higher-level-protocols-built-on-netidx"><a class="header" href="#higher-level-protocols-built-on-netidx">Higher Level Protocols Built on Netidx</a></h1>
<p>Netidx is meant to be a building block out of which more complex
things can be constructed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="remote-procedure-call"><a class="header" href="#remote-procedure-call">Remote Procedure Call</a></h1>
<p>At the library level RPCs in netidix are just like any other RPC.
The procedure name is the netidx path, the arguments are an array
of netidx values. Below the library layer, mapping the RPC model into
netidx is quite simple. e.g.</p>
<pre><code>/app/rpcs/do_thing                            &lt;- the procedure
/app/rpcs/do_thing/doc                        &lt;- procedure doc string
/app/rpcs/do_thing/arg0/val                   &lt;- arguments are all named, this is 'arg0'
/app/rpcs/do_thing/arg0/doc                   &lt;- doc string for arg0
/app/rpcs/do_thing/arg1/val                   &lt;- 'arg1'
/app/rpcs/do_thing/arg1/doc                   &lt;- arg1 doc string
...
/app/rpcs/do_thing/args-can-have-any-name/val &lt;- args can be called anything
/app/rpcs/do_thing/args-can-have-any-name/doc &lt;- doc string
</code></pre>
<p>We set arguments by writing to <code>.../arg-name/val</code>, and we call the
procedure by writing <code>null</code> to the procedure. The return value of the
procedure is sent back to the caller in one of two ways. If the caller
used <code>write_with_recipt</code>, then the return will be sent as the reply to
that write request. If the caller did a normal write, then the
procedure value will be updated with the return value, but only for
the calling client, other clients won't receive this update.</p>
<p>Since there can be time in between setting argument values and
triggering the procedure the rpc module keeps track of the set
argument values on a per client basis. This way, multiple clients may
make independent calls to the same procedure concurrently without
interfering with each other. If arguments are set, but a call is not
triggered within 60 seconds then the arguments may be garbage
collected if the rpc server is busy.</p>
<p>Because the protocol is so simple, it's perfectly possible to call a
netidx rpc directly from the browser using <code>ctrl+w</code>, from the command
line subscriber, or even manually in a program (though the library is
more convenient).</p>
<h2 id="concurrent-rpc-publishers"><a class="header" href="#concurrent-rpc-publishers">Concurrent RPC Publishers</a></h2>
<p>Because of the way netidx works it's entirely possible and supported
for multiple programs on multiple machines to publish the same RPC. As
long as each one publishes the same arguments clients will just pick
one of them at random when initially subscribing, and will use that
one from then on (unless it's forced to resubscribe for watever
reason).</p>
<p>You might wonder, since the procedure and the arguments are different
netidx paths, how it's possible to make sure that a client sends all
it's arguments to the same procedure. Normally in netidx subscriber
picks a random publisher from the set of all publishers publishing the
path it is subscribing to. However the resolver server supports
storing flags for each path, and one of the flags is called
<code>USE_EXISTING</code>, which causes any subscriber to always use an existing
publisher connection (if one exists) instead of picking a random
publisher. Since the RPC library sets this flag on the procedure, and
all the arguments it publishes, subscribers will choose a random
publisher of the RPC when they subscribe to the first path of the rpc,
and thereafter they will always use that publisher (if it fails then
subscriber will pick a new random rpc publisher).</p>
<p>Depending on what your RPC actually does you may need more or less
coordination between publishers, and the cluster protocol can help you
there, but in many cases load balancing is as simple as starting more
publishers to handle additional traffic.</p>
<h2 id="overhead"><a class="header" href="#overhead">Overhead</a></h2>
<p>Once subscribed, the network overhead of calling a netidx rpc is quite
low. For example, consider a procedure with 3 double precision
floating point arguments that also returns a double precision
float. Then the overhead of making a call to this procedure once
subscribed is,</p>
<pre><code># set float arg
tag:       1 byte, 
id:        1 byte, 
value:
  val_tag: 1 byte,
  double:  8 bytes
recipt:    1 byte

# call procedure
tag:    1 byte,
id:     1 byte,
value:  1 byte,
recipt: 1 byte
</code></pre>
<p>So to call a three argument procedure takes 12x3 + 4, or 40 bytes on
the wire, and 24 bytes of that are the actual argument data. The
return value is,</p>
<pre><code>tag:       1 byte,
id:        1 byte,
value:
  val_tag: 1 byte,
  double:  8 bytes
</code></pre>
<p>11 bytes for the return, 8 of which are the actual return value
data. Clearly data size on the wire should be no impedement to using
netidx rpc in high performance applications. Aside from data size on
the wire netidx has some additional beneficial characteristics, for
example, because of the way subscriber and publisher are designed it
is possible for a single client to concurrently issue many rpc calls
to the same publisher, and in that case the messages will
automatically batch allowing processing overhead to be amortized on
both sides. e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>futures::join_all(vec![
    proc.call(args1), 
    proc.call(args2), 
    proc.call(args3)
]).await
<span class="boring">}</span></code></pre></pre>
<p>This will cause only one batch containing all the data needed to make
all three calls to be sent to the publisher. It isn't clear whether
the results will also be sent as a batch, simply because each call may
take a different amount of time to produce a result.</p>
<p>Depending on how the handler for this rpc is written, all three calls
may be evaluated in parallel on the publisher side.  In fact the
default behavior is for concurrent calls to the same procedure to run
in parallel, in order to degrade this one would need to e.g. depend on
a shared locked data structure.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clustering"><a class="header" href="#clustering">Clustering</a></h1>
<p>The cluster protocol uses the resolver server to ease building
distributed services. A cluster is rooted at a particular path. Each
member of the cluster will publish it's uuid under that path, and will
poll for other members. The api provides methods to broadcast to all
members, as well as determine who is the primary (based on uuid sort
order). A cluster with two members might look like, e.g.</p>
<pre><code>/app/cluster/2d66247f02344b5d958039a337b7e218
/app/cluster/bc60c115971e4e1b96c94a3a17f51a86
</code></pre>
<p>Calling the <code>send_to_others</code> method in either member would write a
message to the other. Also, both members would agree that
<code>2d66247f02344b5d958039a337b7e218</code> is the primary, though what meaning
that has depends on the application.</p>
<p>An example application using the cluster protocol is the
recorder. Each recorder shard has access to part of the whole data
set, so in order to replay data accurately, they must coordinate
creating sessions, as well as their position, rate, start, end,
etc. When a shard receives an rpc call asking for a new session, it
forwards that request to all the other shards. Once a session is
created each shard publishes the control interface. Whenever one
receives a command, it forwards that command to the other shards,
ensuring that every shard stays in sync with the user's requests. In
this example, the concept of "primary" is not used, as all the shards
are equal.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Browser specific bscript functions. These are only defined in the
browser.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="confirm"><a class="header" href="#confirm">confirm</a></h1>
<pre><code>confirm(msg: Expr, val: Expr)
</code></pre>
<p>Asks the user msg with val appended, and if they say yes produces it's
second argument, otherwise does not produce anything.</p>
<p>e.g.</p>
<pre><code>store(
  "[base]/volume", 
  confirm(
    "are you sure you want to change the volume to ", 
    volume
  )
)
</code></pre>
<p>Asks the user to confirm before writing the value of the variable
<code>volume</code> to <code>[base]/volume</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="current_path"><a class="header" href="#current_path">current_path</a></h1>
<pre><code>current_path()
</code></pre>
<p>Return the current path of the view in netidx (e.g. the .view netidx
value), or nothing if the view is being loaded from a file. This is
useful if you have an application that the view needs to interact
with, and you want to make the view independent of where the
application is published in netidx.</p>
<pre><code>store("[current_path()]/play", event())
</code></pre>
<p>When the user clicks the play button, store <code>null</code> in <code>play</code> relative
to wherever the application lives in netidx.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event"><a class="header" href="#event">event</a></h1>
<pre><code>event()
</code></pre>
<p>Produces a widget specific event depending on which widget and which
event handler the pipeline containing it is attached to. For example,
when attached to an entry <code>on_change</code> handler it produces the string
value of the entry whenever the user changes the text. When attached
to the on_activate handler of the entry, it produces the string value
of the entry when the user presses the Enter key. When attached to the
<code>on_click</code> handler of a button, it produces Null every time the button
is clicked.</p>
<p>e.g.</p>
<pre><code>store("/text", event())
</code></pre>
<p>When attached to the <code>on_change</code> event of an entry would write the
text to <code>/text</code> every time the user changes it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="navigate"><a class="header" href="#navigate">navigate</a></h1>
<pre><code>navigate(Expr)
</code></pre>
<p>Navigate the browser to the location specified by it's first
argument. The syntax of a location is one of,</p>
<ul>
<li>a valid absolute netidx path, e.g. /foo/bar/baz</li>
<li>a view file e.g. file:/path/to/view/file</li>
<li>a netidx: prefixed netidx path, e.g. netidx:/foo/bar/baz</li>
</ul>
<p>e.g.</p>
<pre><code>navigate(confirm("go to ", "file:[next_view]"))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Container server specific bscript functions. These are only definied in the container.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-1"><a class="header" href="#event-1">event</a></h1>
<pre><code>event()
</code></pre>
<p>When placed in an on_write formula, event produces the value that the
user wrote. The final value of the formula becomes the value that is
actually saved.</p>
<pre><code>filter_err(sum(ref(rel(1)), event()))
</code></pre>
<p>Sum the user's input with the column to the right to produce the final
saved value, but filter out errors in case the user tries to write a
non numeric value.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ref"><a class="header" href="#ref">ref</a></h1>
<pre><code>ref(path: Expr)
</code></pre>
<p>This is equivelent to <code>load(path)</code>, however it is vastly more
efficient. It only works for paths published by the same container
server as is running the formula containg <code>ref</code>.</p>
<pre><code>ref("/container/sheet0/0000/001")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rel"><a class="header" href="#rel">rel</a></h1>
<pre><code>rel()
rel(col: Expr)
rel(row: Expr, col: Expr)
</code></pre>
<p>Return the path of a cell relative to the position of the cell <code>rel</code>
is in. In the first form <code>rel()</code>, the path of the current cell will be
returned. In the second form <code>rel(col)</code>, the path to a cell in the
same row, but a different column will be returned. In the third form
<code>rel(row, col)</code>, the path to a cell in a different row and column will
be returned. The <code>row</code> and <code>col</code> arguments must be integers between
-255 and 255.</p>
<pre><code>sum(1, ref(rel(-1)))
</code></pre>
<p>Add 1 to the value in the column to the left of this formula.</p>
<div style="break-before: page; page-break-before: always;"></div><p>The standard bscript functions reference. These functions are
available in all systems using bscript (currently the browser and the
container server).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="after_idle"><a class="header" href="#after_idle">after_idle</a></h1>
<pre><code>after_idle(timeout: Expr, val: Expr)
</code></pre>
<p>After idle sets a timer when <code>val</code> updates, when the timer expires it
updates with the value produced by <code>val</code>. If <code>val</code> updates again
before the timer expires, then the timer is reset. The timer is a
number of seconds, fractional seconds are accepted, as well as
durations.</p>
<pre><code>store("/foo", after_idle(0.8, event()))
</code></pre>
<p>E.G, do the store only after the user has stopped typing for 800ms.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="all"><a class="header" href="#all">all</a></h1>
<pre><code>all(Expr, ..., Expr)
</code></pre>
<p>All produces the value of it's first argument if the values of all
it's arguments are equal.</p>
<pre><code>all(11, load("/volume"))
</code></pre>
<p>Will produce 11 only when <code>/volume</code> is 11.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="and"><a class="header" href="#and">and</a></h1>
<pre><code>and(Expr, ..., Expr)
</code></pre>
<p>Produces true if all of it's arguments are true, otherwise false.</p>
<p>e.g.</p>
<pre><code>and(load("/cake"), load("/diet"))
</code></pre>
<p>Would produce false.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="any"><a class="header" href="#any">any</a></h1>
<pre><code>any(Expr, ..., Expr)
</code></pre>
<p>Any produces an event every time any of it's arguments produce an event.</p>
<pre><code>any(42, load("/foo/bar"), load("/foo/baz"))
</code></pre>
<p>Will produce 42, and then all the updates to <code>/foo/bar</code> and <code>/foo/baz</code>
in whatever order they arrive.</p>
<pre><code>mean(any(load("/bench/0/0"), load("/bench/0/1")))

</code></pre>
<p>Will produce the average of the values of <code>/bench/0/0</code> and
<code>/bench/0/1</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array"><a class="header" href="#array">array</a></h1>
<pre><code>array(Expr, Expr, ...)
[ Expr, Expr, ... ]
</code></pre>
<p>Construct an array from the values of the specified expressions. If
any of the expressions update, a new array will be constructed with
the updated values and the array function will update.</p>
<pre><code>[ load("/foo"), load("/bar") ]
</code></pre>
<p>Construct a pair from the values of "/foo" and "/bar", update the pair
whenever either of those values changes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basename"><a class="header" href="#basename">basename</a></h1>
<pre><code>basename(path: Expr)
</code></pre>
<p>Return the base name, or file name, of the specified path as a
string. If the argument is not a string return an error. If the path
has no basename, or the string is not a path return <code>null</code></p>
<pre><code>basename("/foo/bar") =&gt; "bar"
basename("/solar/stats/battery_sense_voltage") =&gt; "battery_sense_voltage"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call"><a class="header" href="#call">call</a></h1>
<pre><code>call(trigger: Expr, rpc: Expr, Expr, ..., Expr)
</code></pre>
<p>Call the netidx rpc specified by the second argument, passing the
specified keyword arguments, and producing the return value of the
call. Keyword arguments are encoded as pairs of a name followed by a
value. The rpc will only be called when the specified <code>trigger</code>
updates. If the trigger is a constant then the rpc will only be called
one time after all the args are resolved.</p>
<p>e.g.</p>
<pre><code>let sessionid &lt;- call(
  null,
  "/solar/archive/session", 
  "start", "-10d", 
  "speed", "unlimited", 
  "play_after", "2s"
)
</code></pre>
<p>call <code>/solar/archive/session</code> one time with arguments to replay the
last 10 days, starting 2 seconds after the call finishes, at unlimited
speed, and store the resulting session id in the variable <code>sessionid</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cast"><a class="header" href="#cast">cast</a></h1>
<pre><code>cast(Expr, Expr)
</code></pre>
<p>Attempt to cast the second argument to the type specified by the
first. Produce a value of the specified type, or an error if the cast
is not possible.</p>
<p>e.g.</p>
<pre><code>cast("f32", load("/volume"))
</code></pre>
<p>Changes volume into a single precision float if possible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cmp"><a class="header" href="#cmp">cmp</a></h1>
<pre><code>cmp(Expr, Expr, Expr)
</code></pre>
<p>Produces the result of performing the comparison specified by it's
first argument to it's 2nd and third arugments. Valid comparisons are
encoded as strings, and are called,</p>
<ul>
<li>eq: true if the arguments are equal</li>
<li>lt: true if the first argument is less than the second one</li>
<li>lte: true if the first argument is less than or equal to the second one</li>
<li>gt: true if the first argument is greater than the second one</li>
<li>gte: true if the first argument is greater than or equal to the second one</li>
</ul>
<p>e.g.</p>
<pre><code>cmp("lt", load("/volume"), 11)
</code></pre>
<p>is true if the volume is less than 11, false otherwise.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contains"><a class="header" href="#contains">contains</a></h1>
<pre><code>contains(sub: Expr, string: Expr)
</code></pre>
<p>contains is true if it's arguments are both strings, and it's first
argument is a substring of it's second argument.</p>
<p>e.g</p>
<pre><code>contains("bar", "foobarbaz")
</code></pre>
<p>is true</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="count"><a class="header" href="#count">count</a></h1>
<pre><code>count(Expr)
</code></pre>
<p>Produces the count of events produced by expr since we started
execution of the pipeline.</p>
<p>e.g.</p>
<pre><code>count(load("/volume"))
</code></pre>
<p>will increment every time volume changes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="divide"><a class="header" href="#divide">divide</a></h1>
<pre><code>divide(Expr, Expr, ..., Expr)
</code></pre>
<p>Divides it's first argument by it's subsuquent arguments.</p>
<pre><code>divide(load("/volume"), 2, load("/additional_divisor"))
</code></pre>
<p>First divides <code>"/volume"</code> by 2 and then divides it by
"/additional_divisor".</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="do"><a class="header" href="#do">do</a></h1>
<pre><code>do(Expr, ..., Expr)
{ Expr; ...; Expr }
</code></pre>
<p>Do evaluates to the value of it's final argument, all other arguments
are evaluated for side effect. Each do block aside from the toplevel
one introduces a new lexical scope, let variables defined in such a
scope are not visible outside it.</p>
<p>e.g.</p>
<pre><code>{
    let foo &lt;- "Hello world!";
    store("/tmp/foo", foo);
    foo
}
</code></pre>
<p>evaluates to "Hello world!", but also sets the variable "foo", and
stores it's value to "/tmp/foo".</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ends_with"><a class="header" href="#ends_with">ends_with</a></h1>
<pre><code>ends_with(Expr, Expr)
</code></pre>
<p>ends_with is true if both it's arguments are strings, and the second
argument ends with the first argument.</p>
<p>e.g.</p>
<pre><code>ends_with("foo", "metasyntacticfoo")
ends_with("hello", "hello world")
</code></pre>
<p>The first ends_with is true, and the second one is false</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eval"><a class="header" href="#eval">eval</a></h1>
<pre><code>eval(Expr)
</code></pre>
<p>Compiles and executes the browser script program specified by it's
argument, or produces an error if the program is invalid. This will
produce a node event graph that keeps running until the text of the
code fed to eval changes, which will cause the new program to be
evaluated. As such, once eval is successful for a specific program,
that program will not be semantically distinguisible from bscript that
is part of a view definition or in a container cell.</p>
<p>e.g.</p>
<pre><code>eval(load("[base]/program"))
</code></pre>
<p>Load and execute browser script from <code>[base]/program</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filter_err"><a class="header" href="#filter_err">filter_err</a></h1>
<pre><code>filter_err(Expr)
</code></pre>
<p>Filters out errors in expr. This is equivelent to
<code>filter(not(is_error(expr)), expr)</code>, but is more concise.</p>
<pre><code>filter_err(load("/foo"))
</code></pre>
<p>get the non error values of <code>/foo</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filter"><a class="header" href="#filter">filter</a></h1>
<pre><code>filter(predicate: Expr, Expr)
</code></pre>
<p>filter evaluates to it's second argument if it's first argument
evaluates to true, otherwise it does not pass any events. Note: When
the predicate transitions from false to true then filter will
immediatly evaluate to the last value of it's second argument that it
saw.</p>
<p>e.g.</p>
<pre><code>filter(load("[enabled]"), load("[thing]"))
</code></pre>
<p>Passes on updates to "[thing]" only if "[enabled]" is true</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get"><a class="header" href="#get">get</a></h1>
<pre><code>get(var: Expr)
var
</code></pre>
<p>Produce the value of the variable specified by var, or an error if var
is not a valid variable name. The second form is syntactic sugar that
translates into <code>get("var")</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if"><a class="header" href="#if">if</a></h1>
<pre><code>if(Expr, Expr, [Expr])
</code></pre>
<p>Produces the value of it's 2nd argument if it's first argument is
true, otherwise produces the value of it's third argument, or nothing
if it has no third argument.</p>
<p>e.g.</p>
<pre><code>if(
    cmp("lt", load("/volume"), 11),
    load("/normal_amp"),
    load("/this_one_goes_to_11")
)
</code></pre>
<p>If "/volume" is less than 11 then the value is <code>"/normal_amp"</code>,
otherwise the value is <code>"/this_one_goes_to_11"</code>.</p>
<p>e.g.</p>
<pre><code>if(cmp("eq", 11, load("/volume")), "huzzah!")
</code></pre>
<p>Produces <code>"huzzah!"</code> if <code>/volume</code> is <code>11</code>, otherwise nothing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index"><a class="header" href="#index">index</a></h1>
<pre><code>index(array: Expr, index: Expr)
</code></pre>
<p>returns the zero based indexed element from the specified
array. Returns an error if it's first argument isn't an array, or if
the index is out of bounds.</p>
<pre><code>index([1, 2, 5], 2) =&gt; 5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="isa"><a class="header" href="#isa">isa</a></h1>
<pre><code>isa(Expr, Expr)
</code></pre>
<p>Produce true if the 2nd argument is the type named by the first
argument, false otherwise.</p>
<p>e.g.</p>
<pre><code>isa("f32", 10)
</code></pre>
<p>would produce false.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="is_error"><a class="header" href="#is_error">is_error</a></h1>
<pre><code>is_error(Expr)
</code></pre>
<p>is_error evaluates to true if it's argument evaluates to an error.</p>
<p>e.g.</p>
<pre><code>do(
    set("val", load("/tmp/thing")),
    if(is_error(val), "#REF", val)
)
</code></pre>
<p>if load("/tmp/thing") fails then evaluate to "#REF" otherwise to the
value of load("/tmp/thing").</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="load"><a class="header" href="#load">load</a></h1>
<pre><code>load(Expr)
</code></pre>
<p>Subscribes to the netidx path specified by it's argument, which must
evaluate to a string.</p>
<p>e.g.</p>
<pre><code>load("/some/path/in/netidx")
load("[base]/thing")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="max-1"><a class="header" href="#max-1">max</a></h1>
<pre><code>max(Expr, ..., Expr)
</code></pre>
<p>Produces the largest value of any of it's arguments.</p>
<p>e.g.</p>
<pre><code>max(5, load("/volume"))
</code></pre>
<p>produces the value of "/volume" if it is greater than 5, otherwise it
produces 5.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mean"><a class="header" href="#mean">mean</a></h1>
<pre><code>mean(Expr)
</code></pre>
<p>Computes the average of it's argument over time.</p>
<p>e.g.</p>
<pre><code>mean(load("/volume"))
</code></pre>
<p>Produce the average volume over the observed time period.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="min-1"><a class="header" href="#min-1">min</a></h1>
<pre><code>min(Expr, ..., Expr)
</code></pre>
<p>Produces the smallest value of any of it's arguments.</p>
<p>e.g.</p>
<pre><code>min(42, load("/volume"))
</code></pre>
<p>produces the value of <code>"/volume"</code> if it is less than 42, otherwise it
produces 42.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="not"><a class="header" href="#not">not</a></h1>
<pre><code>not(Expr)
</code></pre>
<p>Produces the opposite of it's argument, e.g. true if it's argument is
false, false otherwise.</p>
<p>e.g.</p>
<pre><code>not(load("/solar/control/charging"))
</code></pre>
<p>true if the battery is not charging.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="once"><a class="header" href="#once">once</a></h1>
<pre><code>once(Expr)
</code></pre>
<p>Returns the value of expr one time. Ignores subsuquent updates.</p>
<pre><code>let foo &lt;- once(filter_err(load("/foo")))
</code></pre>
<p>Save a snapshot of the first non error value of <code>/foo</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="or"><a class="header" href="#or">or</a></h1>
<pre><code>or(Expr, ..., Expr)
</code></pre>
<p>Produces true if any of it's arguments is true, otherwise false.</p>
<p>e.g.</p>
<pre><code>or(load("/cake"), load("/death"))
</code></pre>
<p>Would produce true.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="product"><a class="header" href="#product">product</a></h1>
<pre><code>product(Expr, ..., Expr)
</code></pre>
<p>Produces the product of it's arguments.</p>
<p>e.g.</p>
<pre><code>product(2, 2)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="replace"><a class="header" href="#replace">replace</a></h1>
<pre><code>replace(pat: Expr, replacement: Expr, val: Expr)
</code></pre>
<p>assuming all it's arguments are strings then replace evaluates to val
with all instances of pat replaced with replacement.</p>
<p>e.g.</p>
<pre><code>replace("foo", "bar", "foobarbaz")
</code></pre>
<p>evaluates to "barbarbaz"</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sample"><a class="header" href="#sample">sample</a></h1>
<pre><code>sample(Expr, Expr)
</code></pre>
<p>Produces the value of it's second argument when it's first argument
updates.</p>
<p>e.g.</p>
<pre><code>sample(load("[base]/timestamp"), load("[base]/voltage"))
</code></pre>
<p>Produces <code>[base]/voltage</code> whenever <code>[base]/timestamp</code> updates.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set"><a class="header" href="#set">set</a></h1>
<pre><code>set(name: Expr, val: Expr)
name &lt;- val
</code></pre>
<p>Store the value of val in the variable specified by name. Return
nothing, or an error if name is not a valid variable name. Set will
set the variable defined in the lexical scope closest to it. If the
variable is not defined yet, then set will set it in the global
scope. The second form is a more consise syntax for the first, however
it is less powerful, as name must be a literal name and may not be an
expression.</p>
<p>e.g.</p>
<pre><code>set("volume", cast("f32", event()))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starts_with"><a class="header" href="#starts_with">starts_with</a></h1>
<pre><code>starts_with(pat: Expr, val: Expr)
</code></pre>
<p>evaluates to true if both it's arguments are strings, and the second
argument starts with the first.</p>
<p>e.g.</p>
<pre><code>starts_with("Hello", "Hello World!")
</code></pre>
<p>evaluates to true</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="store"><a class="header" href="#store">store</a></h1>
<pre><code>store(path: Expr, val: Expr)
</code></pre>
<p>store writes val to the specified path assuming it is valid. Store
does not evaluate to anything (in the future it may evaluate to the
result of the store).</p>
<p>A new write will be initiated each time the value of either argument
changes. For example, if the path changes to a new valid path, then
the most recent val will be written immediatly to that new path.</p>
<p>e.g.</p>
<pre><code>store("/tmp/thing", 42)
</code></pre>
<p>write 42 to /tmp/thing</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="let"><a class="header" href="#let">let</a></h1>
<pre><code>let(name: Expr, val: Expr)
let name &lt;- val
</code></pre>
<p>Let is does the same thing as set except that it always sets the
variable in it's own lexical scope. If no variable is defined in it's
lexical scope, then it will define it there. If the variable is
defined in a parent scope, let will cause it to be masked in the
current scope and it's children.</p>
<p>e.g.</p>
<pre><code>{
    let v &lt;- 42;
    {
        let v &lt;- 43;
        v
    }; # evals to 43
    v
} # evals to 42
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string_concat"><a class="header" href="#string_concat">string_concat</a></h1>
<pre><code>string_concat(Expr, ..., Expr)
</code></pre>
<p>Concatinate all arguments.</p>
<p>e.g.</p>
<pre><code>string_concat(load("/foo"), load("/bar"), "baz")
</code></pre>
<p>is the same as writing <code>"[load("/foo")][load("/bar")]baz"</code>. And in
fact string interpolations are just syntactic sugar for this function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string_join"><a class="header" href="#string_join">string_join</a></h1>
<pre><code>string_join(sep: Expr, ..., Expr)
</code></pre>
<p>Concatinate all arguments from 2 ... n using the first argument as a
separator.</p>
<p>e.g.</p>
<pre><code>string_join("/", base, "foo", "bar")
</code></pre>
<p>is the same a writing <code>"[base]/foo/bar"</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strip_prefix"><a class="header" href="#strip_prefix">strip_prefix</a></h1>
<pre><code>strip_prefix(pfx: Expr, val: Expr)
</code></pre>
<p>assuming both it's arguments are strings, then strip_prefix evaluates
to val with pfx removed from the beginning.</p>
<p>e.g.</p>
<pre><code>strip_prefix("Hello ", "Hello World!")
</code></pre>
<p>evaluates to "World!"</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strip_suffix"><a class="header" href="#strip_suffix">strip_suffix</a></h1>
<pre><code>strip_suffix(sfx: Expr, val: Expr)
</code></pre>
<p>assuming both it's arguments are strings, then strip_suffix evaluates
to val with sfx removed from the end.</p>
<p>e.g.</p>
<pre><code>strip_suffix(" World!", "Hello World!")
</code></pre>
<p>evaluates to "Hello"</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sum"><a class="header" href="#sum">sum</a></h1>
<pre><code>sum(Expr, ..., Expr)
</code></pre>
<p>Produces the sum of it's arguments.</p>
<p>e.g.</p>
<pre><code>sum(load("/offset"), load("/random"))
</code></pre>
<p>sums <code>/offset</code> and <code>/random</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timer"><a class="header" href="#timer">timer</a></h1>
<pre><code>timer(duration: Expr, repeat: Expr)
</code></pre>
<p>Set a timer, which will update after <code>duration</code> seconds has
elapsed. If repeat is true, the timer will continue to update every
<code>duration</code> seconds forever. If repeat is a number <code>n</code>, then the timer
will repeat <code>n</code> times. If repeat is <code>false</code>, then the timer will
update just once.</p>
<pre><code>store("/foo/bar", sample(timer(0.5, true), v))
</code></pre>
<p>Store the value of v to <code>/foo/bar</code> twice per second even if it didn't
change.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trim_end"><a class="header" href="#trim_end">trim_end</a></h1>
<pre><code>trim_end(Expr)
</code></pre>
<p>if it's argument is a string, then trim_end evaluates to it's argument
with trailing whitespace removed.</p>
<p>e.g</p>
<pre><code>trim_end("123456   ")
</code></pre>
<p>evaluates to "123456"</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trim"><a class="header" href="#trim">trim</a></h1>
<pre><code>trim(Expr)
</code></pre>
<p>if it's argument is a string, then trim evalutes to it's argument with
both leading and trailing whitespace removed.</p>
<p>e.g.</p>
<pre><code>trim(" aaaaaaaaahhhg  ")
</code></pre>
<p>evaluates to "aaaaaaaaahhhg"</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trim_start"><a class="header" href="#trim_start">trim_start</a></h1>
<pre><code>trim_start(Expr)
</code></pre>
<p>if it's argument is a string, then trim_start evaluates to it's argument
with leading whitespace removed.</p>
<p>e.g</p>
<pre><code>trim_start("   123456")
</code></pre>
<p>evaluates to "123456"</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uniq"><a class="header" href="#uniq">uniq</a></h1>
<pre><code>uniq(Expr)
</code></pre>
<p>Produces the value of it's argument only if that value is different
from the previous one.</p>
<p>e.g.</p>
<pre><code>uniq(load("[stock_base]/ibm/last"))
</code></pre>
<p>Would produce an event only when the last trade price of IBM changes.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
